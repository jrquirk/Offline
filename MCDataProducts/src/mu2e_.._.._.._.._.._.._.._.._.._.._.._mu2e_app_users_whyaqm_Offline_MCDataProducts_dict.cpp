// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME MCDataProductsdIsrcdImu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

// Header files passed as explicit arguments
#include "MCDataProducts/src/classes.h"

// Header files passed via #pragma extra_include

namespace ROOT {
   static TClass *pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary();
   static void pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass*);
   static void *new_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p = 0);
   static void *newArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t size, void *p);
   static void delete_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void deleteArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void destruct_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >*)
   {
      pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >", "string", 190,
                  typeid(pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >) );
      instance.SetNew(&new_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetNewArray(&newArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDelete(&delete_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDestructor(&destruct_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >*)0x0)->GetClass();
      pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_Dictionary();
   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_TClassManip(TClass*);
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p = 0);
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(Long_t size, void *p);
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p);
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p);
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<cet::map_vector_key,mu2e::SimParticle>*)
   {
      pair<cet::map_vector_key,mu2e::SimParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<cet::map_vector_key,mu2e::SimParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<cet::map_vector_key,mu2e::SimParticle>", "string", 190,
                  typeid(pair<cet::map_vector_key,mu2e::SimParticle>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<cet::map_vector_key,mu2e::SimParticle>) );
      instance.SetNew(&new_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR);
      instance.SetNewArray(&newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR);
      instance.SetDelete(&delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR);
      instance.SetDeleteArray(&deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR);
      instance.SetDestructor(&destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::SimParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::SimParticle>*)0x0)->GetClass();
      pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_Dictionary();
   static void pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_TClassManip(TClass*);
   static void *new_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p = 0);
   static void *newArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(Long_t size, void *p);
   static void delete_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p);
   static void deleteArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p);
   static void destruct_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>*)
   {
      pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>", "string", 190,
                  typeid(pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>) );
      instance.SetNew(&new_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR);
      instance.SetNewArray(&newArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR);
      instance.SetDelete(&delete_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR);
      instance.SetDeleteArray(&deleteArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR);
      instance.SetDestructor(&destruct_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>*)0x0)->GetClass();
      pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary();
   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(TClass*);
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p = 0);
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(Long_t size, void *p);
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)
   {
      pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>", "string", 190,
                  typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>) );
      instance.SetNew(&new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetNewArray(&newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDelete(&delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDeleteArray(&deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDestructor(&destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)0x0)->GetClass();
      pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary();
   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(TClass*);
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p = 0);
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(Long_t size, void *p);
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)
   {
      pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>", "string", 190,
                  typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>) );
      instance.SetNew(&new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetNewArray(&newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDelete(&delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDeleteArray(&deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDestructor(&destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)0x0)->GetClass();
      pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary();
   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(TClass*);
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p = 0);
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(Long_t size, void *p);
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)
   {
      pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>", "string", 190,
                  typeid(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>) );
      instance.SetNew(&new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetNewArray(&newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDelete(&delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDeleteArray(&deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDestructor(&destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)0x0)->GetClass();
      pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,double>*)
   {
      pair<art::Ptr<mu2e::SimParticle>,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,double>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,double>", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,double>) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,double>*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >*)
   {
      pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >*)
   {
      pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >*)
   {
      pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >*)
   {
      pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >", "string", 190,
                  typeid(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_Dictionary();
   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_TClassManip(TClass*);
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p = 0);
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(Long_t size, void *p);
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p);
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p);
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<cet::map_vector_key,mu2e::PointTrajectory>*)
   {
      pair<cet::map_vector_key,mu2e::PointTrajectory> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<cet::map_vector_key,mu2e::PointTrajectory>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<cet::map_vector_key,mu2e::PointTrajectory>", "string", 190,
                  typeid(pair<cet::map_vector_key,mu2e::PointTrajectory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_Dictionary, isa_proxy, 4,
                  sizeof(pair<cet::map_vector_key,mu2e::PointTrajectory>) );
      instance.SetNew(&new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR);
      instance.SetNewArray(&newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR);
      instance.SetDelete(&delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR);
      instance.SetDeleteArray(&deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR);
      instance.SetDestructor(&destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::PointTrajectory>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::PointTrajectory>*)0x0)->GetClass();
      pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary();
   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(TClass*);
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p = 0);
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(Long_t size, void *p);
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)
   {
      pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>", "string", 190,
                  typeid(pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary, isa_proxy, 4,
                  sizeof(pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>) );
      instance.SetNew(&new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetNewArray(&newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDelete(&delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDeleteArray(&deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDestructor(&destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)0x0)->GetClass();
      pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_Dictionary();
   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass*);
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p = 0);
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(Long_t size, void *p);
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>*)
   {
      pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>", "string", 190,
                  typeid(pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_Dictionary, isa_proxy, 4,
                  sizeof(pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>) );
      instance.SetNew(&new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR);
      instance.SetNewArray(&newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDelete(&delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDeleteArray(&deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDestructor(&destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>*)0x0)->GetClass();
      pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_TClassManip(theClass);
   return theClass;
   }

   static void pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >", ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >", ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)
   {
      ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>", ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR);

      ::ROOT::AddClassAlternate("art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>","mu2e::GenParticleSPMHistory");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>", ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR);

      ::ROOT::AddClassAlternate("art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>","mu2e::GenSimParticleLink");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR);

      ::ROOT::AddClassAlternate("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>","mu2e::ExtMonFNALPatRecTruthAssns");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)
   {
      ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>", ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR);

      ::ROOT::AddClassAlternate("art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>","mu2e::GenParticleMARSAssns");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>", ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR);

      ::ROOT::AddClassAlternate("art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>","mu2e::SimParticleMARSAssns");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>", ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>", ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >", ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>", ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>", ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >", ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>", ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>", ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>", ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)
   {
      ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>", ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>", ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>", ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)
   {
      ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>", ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>", ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)
   {
      ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>", ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>", ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)
   {
      ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>", ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>::Class_Version(), "canvas/Persistency/Common/Assns.h", 218,
                  typeid(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)
   {
      ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>", ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_Dictionary();
   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_TClassManip(TClass*);
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p = 0);
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(Long_t size, void *p);
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p);
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p);
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)
   {
      ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>", ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>::Class_Version(), "canvas/Persistency/Common/Assns.h", 141,
                  typeid(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>) );
      instance.SetNew(&new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR);
      instance.SetNewArray(&newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR);
      instance.SetDelete(&delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR);
      instance.SetDeleteArray(&deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR);
      instance.SetDestructor(&destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)
   {
      return GenerateInitInstanceLocal((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)0x0)->GetClass();
      artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLCaloDigigR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLCaloDigigR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloDigigR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::CaloDigi>*)
   {
      ::art::Ptr<mu2e::CaloDigi> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::CaloDigi>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::CaloDigi>", ::art::Ptr<mu2e::CaloDigi>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::CaloDigi>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLCaloDigigR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::CaloDigi>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLCaloDigigR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLCaloDigigR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLCaloDigigR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLCaloDigigR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLCaloDigigR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::CaloDigi>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::CaloDigi>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloDigi>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLCaloDigigR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloDigi>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLCaloDigigR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLCaloDigigR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLSimParticlegR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLSimParticlegR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLSimParticlegR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::SimParticle>*)
   {
      ::art::Ptr<mu2e::SimParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::SimParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::SimParticle>", ::art::Ptr<mu2e::SimParticle>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::SimParticle>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLSimParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::SimParticle>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLSimParticlegR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLSimParticlegR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLSimParticlegR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLSimParticlegR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLSimParticlegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::SimParticle>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::SimParticle>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::SimParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLSimParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::SimParticle>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLSimParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLSimParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLGenParticlegR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLGenParticlegR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLGenParticlegR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::GenParticle>*)
   {
      ::art::Ptr<mu2e::GenParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::GenParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::GenParticle>", ::art::Ptr<mu2e::GenParticle>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::GenParticle>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLGenParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::GenParticle>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLGenParticlegR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLGenParticlegR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLGenParticlegR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLGenParticlegR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLGenParticlegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::GenParticle>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::GenParticle>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::GenParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLGenParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::GenParticle>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLGenParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLGenParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLCaloShowerStepgR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLCaloShowerStepgR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::CaloShowerStep>*)
   {
      ::art::Ptr<mu2e::CaloShowerStep> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::CaloShowerStep>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::CaloShowerStep>", ::art::Ptr<mu2e::CaloShowerStep>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::CaloShowerStep>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLCaloShowerStepgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::CaloShowerStep>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLCaloShowerStepgR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLCaloShowerStepgR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLCaloShowerStepgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::CaloShowerStep>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::CaloShowerStep>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloShowerStep>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLCaloShowerStepgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloShowerStep>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLCaloShowerStepgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLCaloShowerStepgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLCaloShowerSimgR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLCaloShowerSimgR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::CaloShowerSim>*)
   {
      ::art::Ptr<mu2e::CaloShowerSim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::CaloShowerSim>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::CaloShowerSim>", ::art::Ptr<mu2e::CaloShowerSim>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::CaloShowerSim>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLCaloShowerSimgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::CaloShowerSim>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLCaloShowerSimgR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLCaloShowerSimgR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLCaloShowerSimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::CaloShowerSim>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::CaloShowerSim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloShowerSim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLCaloShowerSimgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::CaloShowerSim>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLCaloShowerSimgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLCaloShowerSimgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLPtrlEmu2ecLcLStepPointMCgR_Dictionary();
   static void artcLcLPtrlEmu2ecLcLStepPointMCgR_TClassManip(TClass*);
   static void *new_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p = 0);
   static void *newArray_artcLcLPtrlEmu2ecLcLStepPointMCgR(Long_t size, void *p);
   static void delete_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p);
   static void deleteArray_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p);
   static void destruct_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Ptr<mu2e::StepPointMC>*)
   {
      ::art::Ptr<mu2e::StepPointMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Ptr<mu2e::StepPointMC>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Ptr<mu2e::StepPointMC>", ::art::Ptr<mu2e::StepPointMC>::Class_Version(), "canvas/Persistency/Common/Ptr.h", 110,
                  typeid(::art::Ptr<mu2e::StepPointMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLPtrlEmu2ecLcLStepPointMCgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Ptr<mu2e::StepPointMC>) );
      instance.SetNew(&new_artcLcLPtrlEmu2ecLcLStepPointMCgR);
      instance.SetNewArray(&newArray_artcLcLPtrlEmu2ecLcLStepPointMCgR);
      instance.SetDelete(&delete_artcLcLPtrlEmu2ecLcLStepPointMCgR);
      instance.SetDeleteArray(&deleteArray_artcLcLPtrlEmu2ecLcLStepPointMCgR);
      instance.SetDestructor(&destruct_artcLcLPtrlEmu2ecLcLStepPointMCgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Ptr<mu2e::StepPointMC>*)
   {
      return GenerateInitInstanceLocal((::art::Ptr<mu2e::StepPointMC>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Ptr<mu2e::StepPointMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLPtrlEmu2ecLcLStepPointMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Ptr<mu2e::StepPointMC>*)0x0)->GetClass();
      artcLcLPtrlEmu2ecLcLStepPointMCgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLPtrlEmu2ecLcLStepPointMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::ProtonBunchIntensity>*)
   {
      ::art::Wrapper<mu2e::ProtonBunchIntensity> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::ProtonBunchIntensity>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::ProtonBunchIntensity>", ::art::Wrapper<mu2e::ProtonBunchIntensity>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::ProtonBunchIntensity>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::ProtonBunchIntensity>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::ProtonBunchIntensity>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::ProtonBunchIntensity>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::ProtonBunchIntensity>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::ProtonBunchIntensity>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)
   {
      ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >", ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >","art::Wrapper<mu2e::CrvDigiMCCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)
   {
      ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >", ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >","art::Wrapper<mu2e::CrvSiPMChargesCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)
   {
      ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >", ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >","art::Wrapper<mu2e::CrvPhotonsCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >", ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >", ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >", ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLEventWeightgR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLEventWeightgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLEventWeightgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::EventWeight>*)
   {
      ::art::Wrapper<mu2e::EventWeight> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::EventWeight>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::EventWeight>", ::art::Wrapper<mu2e::EventWeight>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::EventWeight>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLEventWeightgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::EventWeight>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLEventWeightgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLEventWeightgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLEventWeightgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLEventWeightgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLEventWeightgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::EventWeight>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::EventWeight>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::EventWeight>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLEventWeightgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::EventWeight>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLEventWeightgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLEventWeightgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)
   {
      ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >", ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >","art::Wrapper<mu2e::SimParticleRemapping>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLGenEventCountgR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLGenEventCountgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::GenEventCount>*)
   {
      ::art::Wrapper<mu2e::GenEventCount> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::GenEventCount>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::GenEventCount>", ::art::Wrapper<mu2e::GenEventCount>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::GenEventCount>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLGenEventCountgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::GenEventCount>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLGenEventCountgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLGenEventCountgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLGenEventCountgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::GenEventCount>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::GenEventCount>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::GenEventCount>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLGenEventCountgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::GenEventCount>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLGenEventCountgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLGenEventCountgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)
   {
      ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >", ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >","art::Wrapper<mu2e::SimParticlePtrCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)
   {
      ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >", ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >","art::Wrapper<mu2e::ExtMonFNALSimHitCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)
   {
      ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >", ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >","art::Wrapper<mu2e::SimParticleTimeMap>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >", ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >","art::Wrapper<mu2e::SimParticleMARSAssns>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >", ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >","art::Wrapper<mu2e::GenParticleMARSAssns>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::MARSInfo> >*)
   {
      ::art::Wrapper<vector<mu2e::MARSInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::MARSInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::MARSInfo> >", ::art::Wrapper<vector<mu2e::MARSInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::MARSInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::MARSInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::MARSInfo> >","art::Wrapper<mu2e::MARSInfoCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::MARSInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::MARSInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::MARSInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::MARSInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >", ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >","art::Wrapper<mu2e::GenSimParticleLink>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_Dictionary();
   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)
   {
      ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >", ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >) );
      instance.SetNew(&new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >","art::Wrapper<mu2e::GenParticleSPMHistory>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)0x0)->GetClass();
      artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)
   {
      ::art::Wrapper<vector<mu2e::VisibleGenElTrack> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::VisibleGenElTrack> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::VisibleGenElTrack> >", ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::VisibleGenElTrack> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::VisibleGenElTrack> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::VisibleGenElTrack> >","art::Wrapper<mu2e::VisibleGenElTrackCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLMixingSummarygR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLMixingSummarygR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::MixingSummary>*)
   {
      ::art::Wrapper<mu2e::MixingSummary> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::MixingSummary>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::MixingSummary>", ::art::Wrapper<mu2e::MixingSummary>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::MixingSummary>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLMixingSummarygR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::MixingSummary>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLMixingSummarygR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLMixingSummarygR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLMixingSummarygR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::MixingSummary>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::MixingSummary>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::MixingSummary>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLMixingSummarygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::MixingSummary>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLMixingSummarygR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLMixingSummarygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)
   {
      ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >", ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >","art::Wrapper<mu2e::PtrStepPointMCVectorCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLStatusG4gR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLStatusG4gR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLStatusG4gR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::StatusG4>*)
   {
      ::art::Wrapper<mu2e::StatusG4> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::StatusG4>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::StatusG4>", ::art::Wrapper<mu2e::StatusG4>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::StatusG4>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLStatusG4gR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::StatusG4>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLStatusG4gR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLStatusG4gR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLStatusG4gR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLStatusG4gR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLStatusG4gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::StatusG4>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::StatusG4>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::StatusG4>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLStatusG4gR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::StatusG4>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLStatusG4gR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLStatusG4gR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_Dictionary();
   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p);
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)
   {
      ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >", ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >) );
      instance.SetNew(&new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >","art::Wrapper<mu2e::MCTrajectoryCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)0x0)->GetClass();
      artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_Dictionary();
   static void artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p);
   static void destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)
   {
      ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >", ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >) );
      instance.SetNew(&new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >","art::Wrapper<mu2e::PointTrajectoryCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)0x0)->GetClass();
      artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)
   {
      ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >", ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >","art::Wrapper<mu2e::ExtMonUCITofHitMCTruthCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloDigi> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloDigi> >", ::art::Wrapper<vector<mu2e::CaloDigi> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloDigi> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloDigi> >","art::Wrapper<mu2e::CaloDigiCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloDigi> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloDigi> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloDigi> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloDigi> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloHitSimPartMC> >", ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloHitSimPartMC> >","art::Wrapper<mu2e::CaloHitSimPartMCCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloDigiMC> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloDigiMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloDigiMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloDigiMC> >", ::art::Wrapper<vector<mu2e::CaloDigiMC> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloDigiMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloDigiMC> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloDigiMC> >","art::Wrapper<mu2e::CaloDigiMCCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloDigiMC> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloDigiMC> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloDigiMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloDigiMC> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloHitMCTruth> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloHitMCTruth> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloHitMCTruth> >", ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloHitMCTruth> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloHitMCTruth> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloHitMCTruth> >","art::Wrapper<mu2e::CaloHitMCTruthCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloShowerSim> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloShowerSim> >", ::art::Wrapper<vector<mu2e::CaloShowerSim> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloShowerSim> >","art::Wrapper<mu2e::CaloShowerSimCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloShowerSim> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloShowerSim> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloShowerStepRO> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloShowerStepRO> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloShowerStepRO> >", ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloShowerStepRO> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloShowerStepRO> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloShowerStepRO> >","art::Wrapper<mu2e::CaloShowerStepROCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::CaloShowerStep> >*)
   {
      ::art::Wrapper<vector<mu2e::CaloShowerStep> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::CaloShowerStep> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::CaloShowerStep> >", ::art::Wrapper<vector<mu2e::CaloShowerStep> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::CaloShowerStep> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::CaloShowerStep> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::CaloShowerStep> >","art::Wrapper<mu2e::CaloShowerStepCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::CaloShowerStep> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::CaloShowerStep> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerStep> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::CaloShowerStep> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)
   {
      ::art::Wrapper<vector<mu2e::G4BeamlineInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::G4BeamlineInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::G4BeamlineInfo> >", ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::G4BeamlineInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::G4BeamlineInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::G4BeamlineInfo> >","art::Wrapper<mu2e::G4BeamlineInfoCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::G4BeamlineInfo>*)
   {
      ::art::Wrapper<mu2e::G4BeamlineInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::G4BeamlineInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::G4BeamlineInfo>", ::art::Wrapper<mu2e::G4BeamlineInfo>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::G4BeamlineInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::G4BeamlineInfo>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::G4BeamlineInfo>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::G4BeamlineInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::G4BeamlineInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::G4BeamlineInfo>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::StrawDigiMC> >*)
   {
      ::art::Wrapper<vector<mu2e::StrawDigiMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::StrawDigiMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::StrawDigiMC> >", ::art::Wrapper<vector<mu2e::StrawDigiMC> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::StrawDigiMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::StrawDigiMC> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::StrawDigiMC> >","art::Wrapper<mu2e::StrawDigiMCCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::StrawDigiMC> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::StrawDigiMC> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StrawDigiMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StrawDigiMC> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)
   {
      ::art::Wrapper<vector<mu2e::StrawHitMCTruth> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::StrawHitMCTruth> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::StrawHitMCTruth> >", ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::StrawHitMCTruth> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::StrawHitMCTruth> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::StrawHitMCTruth> >","art::Wrapper<mu2e::StrawHitMCTruthCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)
   {
      ::art::Wrapper<cet::map_vector<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<cet::map_vector<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<cet::map_vector<mu2e::SimParticle> >", ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<cet::map_vector<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<cet::map_vector<mu2e::SimParticle> >) );
      instance.SetNew(&new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<cet::map_vector<mu2e::SimParticle> >","art::Wrapper<mu2e::SimParticleCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)0x0)->GetClass();
      artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)
   {
      ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >", ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >","art::Wrapper<mu2e::PhysicalVolumeInfoMultiCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)
   {
      ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >", ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >","art::Wrapper<mu2e::PhysicalVolumeInfoCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::StepPointMC> >*)
   {
      ::art::Wrapper<vector<mu2e::StepPointMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::StepPointMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::StepPointMC> >", ::art::Wrapper<vector<mu2e::StepPointMC> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::StepPointMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::StepPointMC> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::StepPointMC> >","art::Wrapper<mu2e::StepPointMCCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::StepPointMC> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::StepPointMC> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StepPointMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::StepPointMC> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_Dictionary();
   static void artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p = 0);
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p);
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p);
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<vector<mu2e::GenParticle> >*)
   {
      ::art::Wrapper<vector<mu2e::GenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<vector<mu2e::GenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<vector<mu2e::GenParticle> >", ::art::Wrapper<vector<mu2e::GenParticle> >::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<vector<mu2e::GenParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<vector<mu2e::GenParticle> >) );
      instance.SetNew(&new_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDelete(&delete_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR);

      ::ROOT::AddClassAlternate("art::Wrapper<vector<mu2e::GenParticle> >","art::Wrapper<mu2e::GenParticleCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<vector<mu2e::GenParticle> >*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<vector<mu2e::GenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::GenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<vector<mu2e::GenParticle> >*)0x0)->GetClass();
      artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *artcLcLWrapperlEmu2ecLcLCaloDigigR_Dictionary();
   static void artcLcLWrapperlEmu2ecLcLCaloDigigR_TClassManip(TClass*);
   static void *new_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p = 0);
   static void *newArray_artcLcLWrapperlEmu2ecLcLCaloDigigR(Long_t size, void *p);
   static void delete_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p);
   static void deleteArray_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p);
   static void destruct_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::art::Wrapper<mu2e::CaloDigi>*)
   {
      ::art::Wrapper<mu2e::CaloDigi> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::art::Wrapper<mu2e::CaloDigi>));
      static ::ROOT::TGenericClassInfo 
         instance("art::Wrapper<mu2e::CaloDigi>", ::art::Wrapper<mu2e::CaloDigi>::Class_Version(), "canvas/Persistency/Common/Wrapper.h", 64,
                  typeid(::art::Wrapper<mu2e::CaloDigi>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &artcLcLWrapperlEmu2ecLcLCaloDigigR_Dictionary, isa_proxy, 4,
                  sizeof(::art::Wrapper<mu2e::CaloDigi>) );
      instance.SetNew(&new_artcLcLWrapperlEmu2ecLcLCaloDigigR);
      instance.SetNewArray(&newArray_artcLcLWrapperlEmu2ecLcLCaloDigigR);
      instance.SetDelete(&delete_artcLcLWrapperlEmu2ecLcLCaloDigigR);
      instance.SetDeleteArray(&deleteArray_artcLcLWrapperlEmu2ecLcLCaloDigigR);
      instance.SetDestructor(&destruct_artcLcLWrapperlEmu2ecLcLCaloDigigR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::art::Wrapper<mu2e::CaloDigi>*)
   {
      return GenerateInitInstanceLocal((::art::Wrapper<mu2e::CaloDigi>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::CaloDigi>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *artcLcLWrapperlEmu2ecLcLCaloDigigR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::art::Wrapper<mu2e::CaloDigi>*)0x0)->GetClass();
      artcLcLWrapperlEmu2ecLcLCaloDigigR_TClassManip(theClass);
   return theClass;
   }

   static void artcLcLWrapperlEmu2ecLcLCaloDigigR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_Dictionary();
   static void cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_TClassManip(TClass*);
   static void *new_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p = 0);
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(Long_t size, void *p);
   static void delete_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p);
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p);
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::cet::map_vector<mu2e::SimParticle>*)
   {
      ::cet::map_vector<mu2e::SimParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::cet::map_vector<mu2e::SimParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("cet::map_vector<mu2e::SimParticle>", ::cet::map_vector<mu2e::SimParticle>::Class_Version(), "cetlib/map_vector.h", 85,
                  typeid(::cet::map_vector<mu2e::SimParticle>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(::cet::map_vector<mu2e::SimParticle>) );
      instance.SetNew(&new_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR);
      instance.SetNewArray(&newArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR);
      instance.SetDelete(&delete_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR);
      instance.SetDeleteArray(&deleteArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR);
      instance.SetDestructor(&destruct_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR);

      ::ROOT::AddClassAlternate("cet::map_vector<mu2e::SimParticle>","mu2e::SimParticleCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::cet::map_vector<mu2e::SimParticle>*)
   {
      return GenerateInitInstanceLocal((::cet::map_vector<mu2e::SimParticle>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::SimParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::SimParticle>*)0x0)->GetClass();
      cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void cetcLcLmap_vectorlEmu2ecLcLSimParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary();
   static void cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass*);
   static void *new_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p = 0);
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(Long_t size, void *p);
   static void delete_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::cet::map_vector<mu2e::PhysicalVolumeInfo>*)
   {
      ::cet::map_vector<mu2e::PhysicalVolumeInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::cet::map_vector<mu2e::PhysicalVolumeInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("cet::map_vector<mu2e::PhysicalVolumeInfo>", ::cet::map_vector<mu2e::PhysicalVolumeInfo>::Class_Version(), "cetlib/map_vector.h", 85,
                  typeid(::cet::map_vector<mu2e::PhysicalVolumeInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary, isa_proxy, 4,
                  sizeof(::cet::map_vector<mu2e::PhysicalVolumeInfo>) );
      instance.SetNew(&new_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetNewArray(&newArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDelete(&delete_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDeleteArray(&deleteArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDestructor(&destruct_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::cet::map_vector<mu2e::PhysicalVolumeInfo>*)
   {
      return GenerateInitInstanceLocal((::cet::map_vector<mu2e::PhysicalVolumeInfo>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::PhysicalVolumeInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::PhysicalVolumeInfo>*)0x0)->GetClass();
      cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(theClass);
   return theClass;
   }

   static void cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_Dictionary();
   static void cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_TClassManip(TClass*);
   static void *new_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p = 0);
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(Long_t size, void *p);
   static void delete_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p);
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p);
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::cet::map_vector<mu2e::PointTrajectory>*)
   {
      ::cet::map_vector<mu2e::PointTrajectory> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::cet::map_vector<mu2e::PointTrajectory>));
      static ::ROOT::TGenericClassInfo 
         instance("cet::map_vector<mu2e::PointTrajectory>", ::cet::map_vector<mu2e::PointTrajectory>::Class_Version(), "cetlib/map_vector.h", 85,
                  typeid(::cet::map_vector<mu2e::PointTrajectory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_Dictionary, isa_proxy, 4,
                  sizeof(::cet::map_vector<mu2e::PointTrajectory>) );
      instance.SetNew(&new_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR);
      instance.SetNewArray(&newArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR);
      instance.SetDelete(&delete_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR);
      instance.SetDeleteArray(&deleteArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR);
      instance.SetDestructor(&destruct_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR);

      ::ROOT::AddClassAlternate("cet::map_vector<mu2e::PointTrajectory>","mu2e::PointTrajectoryCollection");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::cet::map_vector<mu2e::PointTrajectory>*)
   {
      return GenerateInitInstanceLocal((::cet::map_vector<mu2e::PointTrajectory>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::PointTrajectory>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::cet::map_vector<mu2e::PointTrajectory>*)0x0)->GetClass();
      cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_TClassManip(theClass);
   return theClass;
   }

   static void cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloDigi_Dictionary();
   static void mu2ecLcLCaloDigi_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloDigi(void *p = 0);
   static void *newArray_mu2ecLcLCaloDigi(Long_t size, void *p);
   static void delete_mu2ecLcLCaloDigi(void *p);
   static void deleteArray_mu2ecLcLCaloDigi(void *p);
   static void destruct_mu2ecLcLCaloDigi(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloDigi*)
   {
      ::mu2e::CaloDigi *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloDigi));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloDigi", "RecoDataProducts/inc/CaloDigi.hh", 10,
                  typeid(::mu2e::CaloDigi), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloDigi_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloDigi) );
      instance.SetNew(&new_mu2ecLcLCaloDigi);
      instance.SetNewArray(&newArray_mu2ecLcLCaloDigi);
      instance.SetDelete(&delete_mu2ecLcLCaloDigi);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloDigi);
      instance.SetDestructor(&destruct_mu2ecLcLCaloDigi);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloDigi*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloDigi*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloDigi*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloDigi_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloDigi*)0x0)->GetClass();
      mu2ecLcLCaloDigi_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloDigi_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLPDGCode_Dictionary();
   static void mu2ecLcLPDGCode_TClassManip(TClass*);
   static void *new_mu2ecLcLPDGCode(void *p = 0);
   static void *newArray_mu2ecLcLPDGCode(Long_t size, void *p);
   static void delete_mu2ecLcLPDGCode(void *p);
   static void deleteArray_mu2ecLcLPDGCode(void *p);
   static void destruct_mu2ecLcLPDGCode(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::PDGCode*)
   {
      ::mu2e::PDGCode *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::PDGCode));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::PDGCode", "DataProducts/inc/PDGCode.hh", 36,
                  typeid(::mu2e::PDGCode), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLPDGCode_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::PDGCode) );
      instance.SetNew(&new_mu2ecLcLPDGCode);
      instance.SetNewArray(&newArray_mu2ecLcLPDGCode);
      instance.SetDelete(&delete_mu2ecLcLPDGCode);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLPDGCode);
      instance.SetDestructor(&destruct_mu2ecLcLPDGCode);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::PDGCode*)
   {
      return GenerateInitInstanceLocal((::mu2e::PDGCode*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::PDGCode*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLPDGCode_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::PDGCode*)0x0)->GetClass();
      mu2ecLcLPDGCode_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLPDGCode_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLGenId_Dictionary();
   static void mu2ecLcLGenId_TClassManip(TClass*);
   static void *new_mu2ecLcLGenId(void *p = 0);
   static void *newArray_mu2ecLcLGenId(Long_t size, void *p);
   static void delete_mu2ecLcLGenId(void *p);
   static void deleteArray_mu2ecLcLGenId(void *p);
   static void destruct_mu2ecLcLGenId(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::GenId*)
   {
      ::mu2e::GenId *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::GenId));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::GenId", "MCDataProducts/inc/GenId.hh", 31,
                  typeid(::mu2e::GenId), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLGenId_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::GenId) );
      instance.SetNew(&new_mu2ecLcLGenId);
      instance.SetNewArray(&newArray_mu2ecLcLGenId);
      instance.SetDelete(&delete_mu2ecLcLGenId);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLGenId);
      instance.SetDestructor(&destruct_mu2ecLcLGenId);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::GenId*)
   {
      return GenerateInitInstanceLocal((::mu2e::GenId*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::GenId*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLGenId_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::GenId*)0x0)->GetClass();
      mu2ecLcLGenId_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLGenId_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLGenParticle_Dictionary();
   static void mu2ecLcLGenParticle_TClassManip(TClass*);
   static void *new_mu2ecLcLGenParticle(void *p = 0);
   static void *newArray_mu2ecLcLGenParticle(Long_t size, void *p);
   static void delete_mu2ecLcLGenParticle(void *p);
   static void deleteArray_mu2ecLcLGenParticle(void *p);
   static void destruct_mu2ecLcLGenParticle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::GenParticle*)
   {
      ::mu2e::GenParticle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::GenParticle));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::GenParticle", "MCDataProducts/inc/GenParticle.hh", 34,
                  typeid(::mu2e::GenParticle), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLGenParticle_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::GenParticle) );
      instance.SetNew(&new_mu2ecLcLGenParticle);
      instance.SetNewArray(&newArray_mu2ecLcLGenParticle);
      instance.SetDelete(&delete_mu2ecLcLGenParticle);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLGenParticle);
      instance.SetDestructor(&destruct_mu2ecLcLGenParticle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::GenParticle*)
   {
      return GenerateInitInstanceLocal((::mu2e::GenParticle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::GenParticle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLGenParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::GenParticle*)0x0)->GetClass();
      mu2ecLcLGenParticle_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLGenParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLProcessCode_Dictionary();
   static void mu2ecLcLProcessCode_TClassManip(TClass*);
   static void *new_mu2ecLcLProcessCode(void *p = 0);
   static void *newArray_mu2ecLcLProcessCode(Long_t size, void *p);
   static void delete_mu2ecLcLProcessCode(void *p);
   static void deleteArray_mu2ecLcLProcessCode(void *p);
   static void destruct_mu2ecLcLProcessCode(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ProcessCode*)
   {
      ::mu2e::ProcessCode *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ProcessCode));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ProcessCode", "MCDataProducts/inc/ProcessCode.hh", 38,
                  typeid(::mu2e::ProcessCode), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLProcessCode_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ProcessCode) );
      instance.SetNew(&new_mu2ecLcLProcessCode);
      instance.SetNewArray(&newArray_mu2ecLcLProcessCode);
      instance.SetDelete(&delete_mu2ecLcLProcessCode);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLProcessCode);
      instance.SetDestructor(&destruct_mu2ecLcLProcessCode);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ProcessCode*)
   {
      return GenerateInitInstanceLocal((::mu2e::ProcessCode*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ProcessCode*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLProcessCode_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ProcessCode*)0x0)->GetClass();
      mu2ecLcLProcessCode_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLProcessCode_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLSimParticle_Dictionary();
   static void mu2ecLcLSimParticle_TClassManip(TClass*);
   static void *new_mu2ecLcLSimParticle(void *p = 0);
   static void *newArray_mu2ecLcLSimParticle(Long_t size, void *p);
   static void delete_mu2ecLcLSimParticle(void *p);
   static void deleteArray_mu2ecLcLSimParticle(void *p);
   static void destruct_mu2ecLcLSimParticle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::SimParticle*)
   {
      ::mu2e::SimParticle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::SimParticle));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::SimParticle", "MCDataProducts/inc/SimParticle.hh", 42,
                  typeid(::mu2e::SimParticle), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLSimParticle_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::SimParticle) );
      instance.SetNew(&new_mu2ecLcLSimParticle);
      instance.SetNewArray(&newArray_mu2ecLcLSimParticle);
      instance.SetDelete(&delete_mu2ecLcLSimParticle);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLSimParticle);
      instance.SetDestructor(&destruct_mu2ecLcLSimParticle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::SimParticle*)
   {
      return GenerateInitInstanceLocal((::mu2e::SimParticle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::SimParticle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLSimParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::SimParticle*)0x0)->GetClass();
      mu2ecLcLSimParticle_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLSimParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloShowerStep_Dictionary();
   static void mu2ecLcLCaloShowerStep_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloShowerStep(void *p = 0);
   static void *newArray_mu2ecLcLCaloShowerStep(Long_t size, void *p);
   static void delete_mu2ecLcLCaloShowerStep(void *p);
   static void deleteArray_mu2ecLcLCaloShowerStep(void *p);
   static void destruct_mu2ecLcLCaloShowerStep(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloShowerStep*)
   {
      ::mu2e::CaloShowerStep *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloShowerStep));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloShowerStep", "MCDataProducts/inc/CaloShowerStep.hh", 25,
                  typeid(::mu2e::CaloShowerStep), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloShowerStep_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloShowerStep) );
      instance.SetNew(&new_mu2ecLcLCaloShowerStep);
      instance.SetNewArray(&newArray_mu2ecLcLCaloShowerStep);
      instance.SetDelete(&delete_mu2ecLcLCaloShowerStep);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloShowerStep);
      instance.SetDestructor(&destruct_mu2ecLcLCaloShowerStep);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloShowerStep*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloShowerStep*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloShowerStep*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloShowerStep_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloShowerStep*)0x0)->GetClass();
      mu2ecLcLCaloShowerStep_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloShowerStep_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloShowerSim_Dictionary();
   static void mu2ecLcLCaloShowerSim_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloShowerSim(void *p = 0);
   static void *newArray_mu2ecLcLCaloShowerSim(Long_t size, void *p);
   static void delete_mu2ecLcLCaloShowerSim(void *p);
   static void deleteArray_mu2ecLcLCaloShowerSim(void *p);
   static void destruct_mu2ecLcLCaloShowerSim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloShowerSim*)
   {
      ::mu2e::CaloShowerSim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloShowerSim));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloShowerSim", "MCDataProducts/inc/CaloShowerSim.hh", 22,
                  typeid(::mu2e::CaloShowerSim), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloShowerSim_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloShowerSim) );
      instance.SetNew(&new_mu2ecLcLCaloShowerSim);
      instance.SetNewArray(&newArray_mu2ecLcLCaloShowerSim);
      instance.SetDelete(&delete_mu2ecLcLCaloShowerSim);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloShowerSim);
      instance.SetDestructor(&destruct_mu2ecLcLCaloShowerSim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloShowerSim*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloShowerSim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloShowerSim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloShowerSim_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloShowerSim*)0x0)->GetClass();
      mu2ecLcLCaloShowerSim_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloShowerSim_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloShowerStepRO_Dictionary();
   static void mu2ecLcLCaloShowerStepRO_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloShowerStepRO(void *p = 0);
   static void *newArray_mu2ecLcLCaloShowerStepRO(Long_t size, void *p);
   static void delete_mu2ecLcLCaloShowerStepRO(void *p);
   static void deleteArray_mu2ecLcLCaloShowerStepRO(void *p);
   static void destruct_mu2ecLcLCaloShowerStepRO(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloShowerStepRO*)
   {
      ::mu2e::CaloShowerStepRO *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloShowerStepRO));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloShowerStepRO", "MCDataProducts/inc/CaloShowerStepRO.hh", 17,
                  typeid(::mu2e::CaloShowerStepRO), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloShowerStepRO_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloShowerStepRO) );
      instance.SetNew(&new_mu2ecLcLCaloShowerStepRO);
      instance.SetNewArray(&newArray_mu2ecLcLCaloShowerStepRO);
      instance.SetDelete(&delete_mu2ecLcLCaloShowerStepRO);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloShowerStepRO);
      instance.SetDestructor(&destruct_mu2ecLcLCaloShowerStepRO);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloShowerStepRO*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloShowerStepRO*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloShowerStepRO*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloShowerStepRO_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloShowerStepRO*)0x0)->GetClass();
      mu2ecLcLCaloShowerStepRO_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloShowerStepRO_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloHitMCTruth_Dictionary();
   static void mu2ecLcLCaloHitMCTruth_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloHitMCTruth(void *p = 0);
   static void *newArray_mu2ecLcLCaloHitMCTruth(Long_t size, void *p);
   static void delete_mu2ecLcLCaloHitMCTruth(void *p);
   static void deleteArray_mu2ecLcLCaloHitMCTruth(void *p);
   static void destruct_mu2ecLcLCaloHitMCTruth(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloHitMCTruth*)
   {
      ::mu2e::CaloHitMCTruth *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloHitMCTruth));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloHitMCTruth", "MCDataProducts/inc/CaloHitMCTruth.hh", 18,
                  typeid(::mu2e::CaloHitMCTruth), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloHitMCTruth_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloHitMCTruth) );
      instance.SetNew(&new_mu2ecLcLCaloHitMCTruth);
      instance.SetNewArray(&newArray_mu2ecLcLCaloHitMCTruth);
      instance.SetDelete(&delete_mu2ecLcLCaloHitMCTruth);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloHitMCTruth);
      instance.SetDestructor(&destruct_mu2ecLcLCaloHitMCTruth);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloHitMCTruth*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloHitMCTruth*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloHitMCTruth*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloHitMCTruth_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloHitMCTruth*)0x0)->GetClass();
      mu2ecLcLCaloHitMCTruth_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloHitMCTruth_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloDigiMC_Dictionary();
   static void mu2ecLcLCaloDigiMC_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloDigiMC(void *p = 0);
   static void *newArray_mu2ecLcLCaloDigiMC(Long_t size, void *p);
   static void delete_mu2ecLcLCaloDigiMC(void *p);
   static void deleteArray_mu2ecLcLCaloDigiMC(void *p);
   static void destruct_mu2ecLcLCaloDigiMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloDigiMC*)
   {
      ::mu2e::CaloDigiMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloDigiMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloDigiMC", "MCDataProducts/inc/CaloDigiMC.hh", 17,
                  typeid(::mu2e::CaloDigiMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloDigiMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloDigiMC) );
      instance.SetNew(&new_mu2ecLcLCaloDigiMC);
      instance.SetNewArray(&newArray_mu2ecLcLCaloDigiMC);
      instance.SetDelete(&delete_mu2ecLcLCaloDigiMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloDigiMC);
      instance.SetDestructor(&destruct_mu2ecLcLCaloDigiMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloDigiMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloDigiMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloDigiMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloDigiMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloDigiMC*)0x0)->GetClass();
      mu2ecLcLCaloDigiMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloDigiMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLStepPointMC_Dictionary();
   static void mu2ecLcLStepPointMC_TClassManip(TClass*);
   static void *new_mu2ecLcLStepPointMC(void *p = 0);
   static void *newArray_mu2ecLcLStepPointMC(Long_t size, void *p);
   static void delete_mu2ecLcLStepPointMC(void *p);
   static void deleteArray_mu2ecLcLStepPointMC(void *p);
   static void destruct_mu2ecLcLStepPointMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::StepPointMC*)
   {
      ::mu2e::StepPointMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::StepPointMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::StepPointMC", "MCDataProducts/inc/StepPointMC.hh", 33,
                  typeid(::mu2e::StepPointMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLStepPointMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::StepPointMC) );
      instance.SetNew(&new_mu2ecLcLStepPointMC);
      instance.SetNewArray(&newArray_mu2ecLcLStepPointMC);
      instance.SetDelete(&delete_mu2ecLcLStepPointMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLStepPointMC);
      instance.SetDestructor(&destruct_mu2ecLcLStepPointMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::StepPointMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::StepPointMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::StepPointMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLStepPointMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::StepPointMC*)0x0)->GetClass();
      mu2ecLcLStepPointMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLStepPointMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloHitSimPartMC_Dictionary();
   static void mu2ecLcLCaloHitSimPartMC_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloHitSimPartMC(void *p = 0);
   static void *newArray_mu2ecLcLCaloHitSimPartMC(Long_t size, void *p);
   static void delete_mu2ecLcLCaloHitSimPartMC(void *p);
   static void deleteArray_mu2ecLcLCaloHitSimPartMC(void *p);
   static void destruct_mu2ecLcLCaloHitSimPartMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloHitSimPartMC*)
   {
      ::mu2e::CaloHitSimPartMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloHitSimPartMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloHitSimPartMC", "MCDataProducts/inc/CaloHitSimPartMC.hh", 26,
                  typeid(::mu2e::CaloHitSimPartMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloHitSimPartMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloHitSimPartMC) );
      instance.SetNew(&new_mu2ecLcLCaloHitSimPartMC);
      instance.SetNewArray(&newArray_mu2ecLcLCaloHitSimPartMC);
      instance.SetDelete(&delete_mu2ecLcLCaloHitSimPartMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloHitSimPartMC);
      instance.SetDestructor(&destruct_mu2ecLcLCaloHitSimPartMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloHitSimPartMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloHitSimPartMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloHitSimPartMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloHitSimPartMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloHitSimPartMC*)0x0)->GetClass();
      mu2ecLcLCaloHitSimPartMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloHitSimPartMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCaloClusterContentMC_Dictionary();
   static void mu2ecLcLCaloClusterContentMC_TClassManip(TClass*);
   static void *new_mu2ecLcLCaloClusterContentMC(void *p = 0);
   static void *newArray_mu2ecLcLCaloClusterContentMC(Long_t size, void *p);
   static void delete_mu2ecLcLCaloClusterContentMC(void *p);
   static void deleteArray_mu2ecLcLCaloClusterContentMC(void *p);
   static void destruct_mu2ecLcLCaloClusterContentMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CaloClusterContentMC*)
   {
      ::mu2e::CaloClusterContentMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CaloClusterContentMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CaloClusterContentMC", "MCDataProducts/inc/CaloClusterContentMC.hh", 20,
                  typeid(::mu2e::CaloClusterContentMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCaloClusterContentMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CaloClusterContentMC) );
      instance.SetNew(&new_mu2ecLcLCaloClusterContentMC);
      instance.SetNewArray(&newArray_mu2ecLcLCaloClusterContentMC);
      instance.SetDelete(&delete_mu2ecLcLCaloClusterContentMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCaloClusterContentMC);
      instance.SetDestructor(&destruct_mu2ecLcLCaloClusterContentMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CaloClusterContentMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::CaloClusterContentMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CaloClusterContentMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCaloClusterContentMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CaloClusterContentMC*)0x0)->GetClass();
      mu2ecLcLCaloClusterContentMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCaloClusterContentMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvPhotons_Dictionary();
   static void mu2ecLcLCrvPhotons_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvPhotons(void *p = 0);
   static void *newArray_mu2ecLcLCrvPhotons(Long_t size, void *p);
   static void delete_mu2ecLcLCrvPhotons(void *p);
   static void deleteArray_mu2ecLcLCrvPhotons(void *p);
   static void destruct_mu2ecLcLCrvPhotons(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvPhotons*)
   {
      ::mu2e::CrvPhotons *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvPhotons));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvPhotons", "MCDataProducts/inc/CrvPhotons.hh", 16,
                  typeid(::mu2e::CrvPhotons), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvPhotons_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvPhotons) );
      instance.SetNew(&new_mu2ecLcLCrvPhotons);
      instance.SetNewArray(&newArray_mu2ecLcLCrvPhotons);
      instance.SetDelete(&delete_mu2ecLcLCrvPhotons);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvPhotons);
      instance.SetDestructor(&destruct_mu2ecLcLCrvPhotons);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvPhotons*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvPhotons*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvPhotons*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvPhotons_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvPhotons*)0x0)->GetClass();
      mu2ecLcLCrvPhotons_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvPhotons_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvPhotonscLcLSinglePhoton_Dictionary();
   static void mu2ecLcLCrvPhotonscLcLSinglePhoton_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p = 0);
   static void *newArray_mu2ecLcLCrvPhotonscLcLSinglePhoton(Long_t size, void *p);
   static void delete_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p);
   static void deleteArray_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p);
   static void destruct_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvPhotons::SinglePhoton*)
   {
      ::mu2e::CrvPhotons::SinglePhoton *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvPhotons::SinglePhoton));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvPhotons::SinglePhoton", "MCDataProducts/inc/CrvPhotons.hh", 20,
                  typeid(::mu2e::CrvPhotons::SinglePhoton), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvPhotonscLcLSinglePhoton_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvPhotons::SinglePhoton) );
      instance.SetNew(&new_mu2ecLcLCrvPhotonscLcLSinglePhoton);
      instance.SetNewArray(&newArray_mu2ecLcLCrvPhotonscLcLSinglePhoton);
      instance.SetDelete(&delete_mu2ecLcLCrvPhotonscLcLSinglePhoton);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvPhotonscLcLSinglePhoton);
      instance.SetDestructor(&destruct_mu2ecLcLCrvPhotonscLcLSinglePhoton);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvPhotons::SinglePhoton*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvPhotons::SinglePhoton*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvPhotons::SinglePhoton*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvPhotonscLcLSinglePhoton_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvPhotons::SinglePhoton*)0x0)->GetClass();
      mu2ecLcLCrvPhotonscLcLSinglePhoton_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvPhotonscLcLSinglePhoton_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvSiPMCharges_Dictionary();
   static void mu2ecLcLCrvSiPMCharges_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvSiPMCharges(void *p = 0);
   static void *newArray_mu2ecLcLCrvSiPMCharges(Long_t size, void *p);
   static void delete_mu2ecLcLCrvSiPMCharges(void *p);
   static void deleteArray_mu2ecLcLCrvSiPMCharges(void *p);
   static void destruct_mu2ecLcLCrvSiPMCharges(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvSiPMCharges*)
   {
      ::mu2e::CrvSiPMCharges *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvSiPMCharges));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvSiPMCharges", "MCDataProducts/inc/CrvSiPMCharges.hh", 17,
                  typeid(::mu2e::CrvSiPMCharges), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvSiPMCharges_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvSiPMCharges) );
      instance.SetNew(&new_mu2ecLcLCrvSiPMCharges);
      instance.SetNewArray(&newArray_mu2ecLcLCrvSiPMCharges);
      instance.SetDelete(&delete_mu2ecLcLCrvSiPMCharges);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvSiPMCharges);
      instance.SetDestructor(&destruct_mu2ecLcLCrvSiPMCharges);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvSiPMCharges*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvSiPMCharges*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvSiPMCharges*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvSiPMCharges_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvSiPMCharges*)0x0)->GetClass();
      mu2ecLcLCrvSiPMCharges_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvSiPMCharges_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_Dictionary();
   static void mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p = 0);
   static void *newArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(Long_t size, void *p);
   static void delete_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p);
   static void deleteArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p);
   static void destruct_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvSiPMCharges::CrvSingleCharge*)
   {
      ::mu2e::CrvSiPMCharges::CrvSingleCharge *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvSiPMCharges::CrvSingleCharge));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvSiPMCharges::CrvSingleCharge", "MCDataProducts/inc/CrvSiPMCharges.hh", 23,
                  typeid(::mu2e::CrvSiPMCharges::CrvSingleCharge), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvSiPMCharges::CrvSingleCharge) );
      instance.SetNew(&new_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge);
      instance.SetNewArray(&newArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge);
      instance.SetDelete(&delete_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge);
      instance.SetDestructor(&destruct_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvSiPMCharges::CrvSingleCharge*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvSiPMCharges::CrvSingleCharge*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvSiPMCharges::CrvSingleCharge*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvSiPMCharges::CrvSingleCharge*)0x0)->GetClass();
      mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvDigiMC_Dictionary();
   static void mu2ecLcLCrvDigiMC_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvDigiMC(void *p = 0);
   static void *newArray_mu2ecLcLCrvDigiMC(Long_t size, void *p);
   static void delete_mu2ecLcLCrvDigiMC(void *p);
   static void deleteArray_mu2ecLcLCrvDigiMC(void *p);
   static void destruct_mu2ecLcLCrvDigiMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvDigiMC*)
   {
      ::mu2e::CrvDigiMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvDigiMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvDigiMC", "MCDataProducts/inc/CrvDigiMC.hh", 16,
                  typeid(::mu2e::CrvDigiMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvDigiMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvDigiMC) );
      instance.SetNew(&new_mu2ecLcLCrvDigiMC);
      instance.SetNewArray(&newArray_mu2ecLcLCrvDigiMC);
      instance.SetDelete(&delete_mu2ecLcLCrvDigiMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvDigiMC);
      instance.SetDestructor(&destruct_mu2ecLcLCrvDigiMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvDigiMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvDigiMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvDigiMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvDigiMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvDigiMC*)0x0)->GetClass();
      mu2ecLcLCrvDigiMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvDigiMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_Dictionary();
   static void mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_TClassManip(TClass*);
   static void *new_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p = 0);
   static void *newArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(Long_t size, void *p);
   static void delete_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p);
   static void deleteArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p);
   static void destruct_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::CrvDigiMC::CrvSingleWaveform*)
   {
      ::mu2e::CrvDigiMC::CrvSingleWaveform *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::CrvDigiMC::CrvSingleWaveform));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::CrvDigiMC::CrvSingleWaveform", "MCDataProducts/inc/CrvDigiMC.hh", 22,
                  typeid(::mu2e::CrvDigiMC::CrvSingleWaveform), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::CrvDigiMC::CrvSingleWaveform) );
      instance.SetNew(&new_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform);
      instance.SetNewArray(&newArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform);
      instance.SetDelete(&delete_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform);
      instance.SetDestructor(&destruct_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::CrvDigiMC::CrvSingleWaveform*)
   {
      return GenerateInitInstanceLocal((::mu2e::CrvDigiMC::CrvSingleWaveform*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::CrvDigiMC::CrvSingleWaveform*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::CrvDigiMC::CrvSingleWaveform*)0x0)->GetClass();
      mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLExtMonUCITofHitMCTruth_Dictionary();
   static void mu2ecLcLExtMonUCITofHitMCTruth_TClassManip(TClass*);
   static void *new_mu2ecLcLExtMonUCITofHitMCTruth(void *p = 0);
   static void *newArray_mu2ecLcLExtMonUCITofHitMCTruth(Long_t size, void *p);
   static void delete_mu2ecLcLExtMonUCITofHitMCTruth(void *p);
   static void deleteArray_mu2ecLcLExtMonUCITofHitMCTruth(void *p);
   static void destruct_mu2ecLcLExtMonUCITofHitMCTruth(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ExtMonUCITofHitMCTruth*)
   {
      ::mu2e::ExtMonUCITofHitMCTruth *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ExtMonUCITofHitMCTruth));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ExtMonUCITofHitMCTruth", "MCDataProducts/inc/ExtMonUCITofHitMCTruth.hh", 19,
                  typeid(::mu2e::ExtMonUCITofHitMCTruth), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLExtMonUCITofHitMCTruth_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ExtMonUCITofHitMCTruth) );
      instance.SetNew(&new_mu2ecLcLExtMonUCITofHitMCTruth);
      instance.SetNewArray(&newArray_mu2ecLcLExtMonUCITofHitMCTruth);
      instance.SetDelete(&delete_mu2ecLcLExtMonUCITofHitMCTruth);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLExtMonUCITofHitMCTruth);
      instance.SetDestructor(&destruct_mu2ecLcLExtMonUCITofHitMCTruth);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ExtMonUCITofHitMCTruth*)
   {
      return GenerateInitInstanceLocal((::mu2e::ExtMonUCITofHitMCTruth*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ExtMonUCITofHitMCTruth*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLExtMonUCITofHitMCTruth_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ExtMonUCITofHitMCTruth*)0x0)->GetClass();
      mu2ecLcLExtMonUCITofHitMCTruth_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLExtMonUCITofHitMCTruth_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLG4BeamlineInfo_Dictionary();
   static void mu2ecLcLG4BeamlineInfo_TClassManip(TClass*);
   static void *new_mu2ecLcLG4BeamlineInfo(void *p = 0);
   static void *newArray_mu2ecLcLG4BeamlineInfo(Long_t size, void *p);
   static void delete_mu2ecLcLG4BeamlineInfo(void *p);
   static void deleteArray_mu2ecLcLG4BeamlineInfo(void *p);
   static void destruct_mu2ecLcLG4BeamlineInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::G4BeamlineInfo*)
   {
      ::mu2e::G4BeamlineInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::G4BeamlineInfo));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::G4BeamlineInfo", "MCDataProducts/inc/G4BeamlineInfo.hh", 10,
                  typeid(::mu2e::G4BeamlineInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLG4BeamlineInfo_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::G4BeamlineInfo) );
      instance.SetNew(&new_mu2ecLcLG4BeamlineInfo);
      instance.SetNewArray(&newArray_mu2ecLcLG4BeamlineInfo);
      instance.SetDelete(&delete_mu2ecLcLG4BeamlineInfo);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLG4BeamlineInfo);
      instance.SetDestructor(&destruct_mu2ecLcLG4BeamlineInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::G4BeamlineInfo*)
   {
      return GenerateInitInstanceLocal((::mu2e::G4BeamlineInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::G4BeamlineInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLG4BeamlineInfo_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::G4BeamlineInfo*)0x0)->GetClass();
      mu2ecLcLG4BeamlineInfo_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLG4BeamlineInfo_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLPhysicalVolumeInfo_Dictionary();
   static void mu2ecLcLPhysicalVolumeInfo_TClassManip(TClass*);
   static void *new_mu2ecLcLPhysicalVolumeInfo(void *p = 0);
   static void *newArray_mu2ecLcLPhysicalVolumeInfo(Long_t size, void *p);
   static void delete_mu2ecLcLPhysicalVolumeInfo(void *p);
   static void deleteArray_mu2ecLcLPhysicalVolumeInfo(void *p);
   static void destruct_mu2ecLcLPhysicalVolumeInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::PhysicalVolumeInfo*)
   {
      ::mu2e::PhysicalVolumeInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::PhysicalVolumeInfo));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::PhysicalVolumeInfo", "MCDataProducts/inc/PhysicalVolumeInfo.hh", 20,
                  typeid(::mu2e::PhysicalVolumeInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLPhysicalVolumeInfo_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::PhysicalVolumeInfo) );
      instance.SetNew(&new_mu2ecLcLPhysicalVolumeInfo);
      instance.SetNewArray(&newArray_mu2ecLcLPhysicalVolumeInfo);
      instance.SetDelete(&delete_mu2ecLcLPhysicalVolumeInfo);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLPhysicalVolumeInfo);
      instance.SetDestructor(&destruct_mu2ecLcLPhysicalVolumeInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::PhysicalVolumeInfo*)
   {
      return GenerateInitInstanceLocal((::mu2e::PhysicalVolumeInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::PhysicalVolumeInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLPhysicalVolumeInfo_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::PhysicalVolumeInfo*)0x0)->GetClass();
      mu2ecLcLPhysicalVolumeInfo_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLPhysicalVolumeInfo_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLMCTrajectory_Dictionary();
   static void mu2ecLcLMCTrajectory_TClassManip(TClass*);
   static void *new_mu2ecLcLMCTrajectory(void *p = 0);
   static void *newArray_mu2ecLcLMCTrajectory(Long_t size, void *p);
   static void delete_mu2ecLcLMCTrajectory(void *p);
   static void deleteArray_mu2ecLcLMCTrajectory(void *p);
   static void destruct_mu2ecLcLMCTrajectory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::MCTrajectory*)
   {
      ::mu2e::MCTrajectory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::MCTrajectory));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::MCTrajectory", "MCDataProducts/inc/MCTrajectory.hh", 22,
                  typeid(::mu2e::MCTrajectory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLMCTrajectory_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::MCTrajectory) );
      instance.SetNew(&new_mu2ecLcLMCTrajectory);
      instance.SetNewArray(&newArray_mu2ecLcLMCTrajectory);
      instance.SetDelete(&delete_mu2ecLcLMCTrajectory);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLMCTrajectory);
      instance.SetDestructor(&destruct_mu2ecLcLMCTrajectory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::MCTrajectory*)
   {
      return GenerateInitInstanceLocal((::mu2e::MCTrajectory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::MCTrajectory*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLMCTrajectory_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::MCTrajectory*)0x0)->GetClass();
      mu2ecLcLMCTrajectory_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLMCTrajectory_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLPointTrajectory_Dictionary();
   static void mu2ecLcLPointTrajectory_TClassManip(TClass*);
   static void *new_mu2ecLcLPointTrajectory(void *p = 0);
   static void *newArray_mu2ecLcLPointTrajectory(Long_t size, void *p);
   static void delete_mu2ecLcLPointTrajectory(void *p);
   static void deleteArray_mu2ecLcLPointTrajectory(void *p);
   static void destruct_mu2ecLcLPointTrajectory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::PointTrajectory*)
   {
      ::mu2e::PointTrajectory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::PointTrajectory));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::PointTrajectory", "MCDataProducts/inc/PointTrajectory.hh", 21,
                  typeid(::mu2e::PointTrajectory), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLPointTrajectory_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::PointTrajectory) );
      instance.SetNew(&new_mu2ecLcLPointTrajectory);
      instance.SetNewArray(&newArray_mu2ecLcLPointTrajectory);
      instance.SetDelete(&delete_mu2ecLcLPointTrajectory);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLPointTrajectory);
      instance.SetDestructor(&destruct_mu2ecLcLPointTrajectory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::PointTrajectory*)
   {
      return GenerateInitInstanceLocal((::mu2e::PointTrajectory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::PointTrajectory*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLPointTrajectory_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::PointTrajectory*)0x0)->GetClass();
      mu2ecLcLPointTrajectory_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLPointTrajectory_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLStatusG4_Dictionary();
   static void mu2ecLcLStatusG4_TClassManip(TClass*);
   static void *new_mu2ecLcLStatusG4(void *p = 0);
   static void *newArray_mu2ecLcLStatusG4(Long_t size, void *p);
   static void delete_mu2ecLcLStatusG4(void *p);
   static void deleteArray_mu2ecLcLStatusG4(void *p);
   static void destruct_mu2ecLcLStatusG4(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::StatusG4*)
   {
      ::mu2e::StatusG4 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::StatusG4));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::StatusG4", "MCDataProducts/inc/StatusG4.hh", 32,
                  typeid(::mu2e::StatusG4), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLStatusG4_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::StatusG4) );
      instance.SetNew(&new_mu2ecLcLStatusG4);
      instance.SetNewArray(&newArray_mu2ecLcLStatusG4);
      instance.SetDelete(&delete_mu2ecLcLStatusG4);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLStatusG4);
      instance.SetDestructor(&destruct_mu2ecLcLStatusG4);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::StatusG4*)
   {
      return GenerateInitInstanceLocal((::mu2e::StatusG4*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::StatusG4*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLStatusG4_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::StatusG4*)0x0)->GetClass();
      mu2ecLcLStatusG4_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLStatusG4_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLStrawHitMCTruth_Dictionary();
   static void mu2ecLcLStrawHitMCTruth_TClassManip(TClass*);
   static void *new_mu2ecLcLStrawHitMCTruth(void *p = 0);
   static void *newArray_mu2ecLcLStrawHitMCTruth(Long_t size, void *p);
   static void delete_mu2ecLcLStrawHitMCTruth(void *p);
   static void deleteArray_mu2ecLcLStrawHitMCTruth(void *p);
   static void destruct_mu2ecLcLStrawHitMCTruth(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::StrawHitMCTruth*)
   {
      ::mu2e::StrawHitMCTruth *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::StrawHitMCTruth));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::StrawHitMCTruth", "MCDataProducts/inc/StrawHitMCTruth.hh", 18,
                  typeid(::mu2e::StrawHitMCTruth), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLStrawHitMCTruth_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::StrawHitMCTruth) );
      instance.SetNew(&new_mu2ecLcLStrawHitMCTruth);
      instance.SetNewArray(&newArray_mu2ecLcLStrawHitMCTruth);
      instance.SetDelete(&delete_mu2ecLcLStrawHitMCTruth);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLStrawHitMCTruth);
      instance.SetDestructor(&destruct_mu2ecLcLStrawHitMCTruth);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::StrawHitMCTruth*)
   {
      return GenerateInitInstanceLocal((::mu2e::StrawHitMCTruth*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::StrawHitMCTruth*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLStrawHitMCTruth_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::StrawHitMCTruth*)0x0)->GetClass();
      mu2ecLcLStrawHitMCTruth_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLStrawHitMCTruth_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLStrawDigiMC_Dictionary();
   static void mu2ecLcLStrawDigiMC_TClassManip(TClass*);
   static void *new_mu2ecLcLStrawDigiMC(void *p = 0);
   static void *newArray_mu2ecLcLStrawDigiMC(Long_t size, void *p);
   static void delete_mu2ecLcLStrawDigiMC(void *p);
   static void deleteArray_mu2ecLcLStrawDigiMC(void *p);
   static void destruct_mu2ecLcLStrawDigiMC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::StrawDigiMC*)
   {
      ::mu2e::StrawDigiMC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::StrawDigiMC));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::StrawDigiMC", "MCDataProducts/inc/StrawDigiMC.hh", 25,
                  typeid(::mu2e::StrawDigiMC), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLStrawDigiMC_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::StrawDigiMC) );
      instance.SetNew(&new_mu2ecLcLStrawDigiMC);
      instance.SetNewArray(&newArray_mu2ecLcLStrawDigiMC);
      instance.SetDelete(&delete_mu2ecLcLStrawDigiMC);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLStrawDigiMC);
      instance.SetDestructor(&destruct_mu2ecLcLStrawDigiMC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::StrawDigiMC*)
   {
      return GenerateInitInstanceLocal((::mu2e::StrawDigiMC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::StrawDigiMC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLStrawDigiMC_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::StrawDigiMC*)0x0)->GetClass();
      mu2ecLcLStrawDigiMC_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLStrawDigiMC_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLMixingSummary_Dictionary();
   static void mu2ecLcLMixingSummary_TClassManip(TClass*);
   static void *new_mu2ecLcLMixingSummary(void *p = 0);
   static void *newArray_mu2ecLcLMixingSummary(Long_t size, void *p);
   static void delete_mu2ecLcLMixingSummary(void *p);
   static void deleteArray_mu2ecLcLMixingSummary(void *p);
   static void destruct_mu2ecLcLMixingSummary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::MixingSummary*)
   {
      ::mu2e::MixingSummary *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::MixingSummary));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::MixingSummary", "MCDataProducts/inc/MixingSummary.hh", 25,
                  typeid(::mu2e::MixingSummary), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLMixingSummary_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::MixingSummary) );
      instance.SetNew(&new_mu2ecLcLMixingSummary);
      instance.SetNewArray(&newArray_mu2ecLcLMixingSummary);
      instance.SetDelete(&delete_mu2ecLcLMixingSummary);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLMixingSummary);
      instance.SetDestructor(&destruct_mu2ecLcLMixingSummary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::MixingSummary*)
   {
      return GenerateInitInstanceLocal((::mu2e::MixingSummary*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::MixingSummary*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLMixingSummary_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::MixingSummary*)0x0)->GetClass();
      mu2ecLcLMixingSummary_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLMixingSummary_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLGenElHitData_Dictionary();
   static void mu2ecLcLGenElHitData_TClassManip(TClass*);
   static void *new_mu2ecLcLGenElHitData(void *p = 0);
   static void *newArray_mu2ecLcLGenElHitData(Long_t size, void *p);
   static void delete_mu2ecLcLGenElHitData(void *p);
   static void deleteArray_mu2ecLcLGenElHitData(void *p);
   static void destruct_mu2ecLcLGenElHitData(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::GenElHitData*)
   {
      ::mu2e::GenElHitData *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::GenElHitData));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::GenElHitData", "MCDataProducts/inc/GenElHitData.hh", 29,
                  typeid(::mu2e::GenElHitData), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLGenElHitData_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::GenElHitData) );
      instance.SetNew(&new_mu2ecLcLGenElHitData);
      instance.SetNewArray(&newArray_mu2ecLcLGenElHitData);
      instance.SetDelete(&delete_mu2ecLcLGenElHitData);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLGenElHitData);
      instance.SetDestructor(&destruct_mu2ecLcLGenElHitData);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::GenElHitData*)
   {
      return GenerateInitInstanceLocal((::mu2e::GenElHitData*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::GenElHitData*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLGenElHitData_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::GenElHitData*)0x0)->GetClass();
      mu2ecLcLGenElHitData_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLGenElHitData_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLVisibleGenElTrack_Dictionary();
   static void mu2ecLcLVisibleGenElTrack_TClassManip(TClass*);
   static void *new_mu2ecLcLVisibleGenElTrack(void *p = 0);
   static void *newArray_mu2ecLcLVisibleGenElTrack(Long_t size, void *p);
   static void delete_mu2ecLcLVisibleGenElTrack(void *p);
   static void deleteArray_mu2ecLcLVisibleGenElTrack(void *p);
   static void destruct_mu2ecLcLVisibleGenElTrack(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::VisibleGenElTrack*)
   {
      ::mu2e::VisibleGenElTrack *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::VisibleGenElTrack));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::VisibleGenElTrack", "MCDataProducts/inc/VisibleGenElTrack.hh", 39,
                  typeid(::mu2e::VisibleGenElTrack), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLVisibleGenElTrack_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::VisibleGenElTrack) );
      instance.SetNew(&new_mu2ecLcLVisibleGenElTrack);
      instance.SetNewArray(&newArray_mu2ecLcLVisibleGenElTrack);
      instance.SetDelete(&delete_mu2ecLcLVisibleGenElTrack);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLVisibleGenElTrack);
      instance.SetDestructor(&destruct_mu2ecLcLVisibleGenElTrack);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::VisibleGenElTrack*)
   {
      return GenerateInitInstanceLocal((::mu2e::VisibleGenElTrack*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::VisibleGenElTrack*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLVisibleGenElTrack_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::VisibleGenElTrack*)0x0)->GetClass();
      mu2ecLcLVisibleGenElTrack_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLVisibleGenElTrack_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLExtMonFNALSimHit_Dictionary();
   static void mu2ecLcLExtMonFNALSimHit_TClassManip(TClass*);
   static void *new_mu2ecLcLExtMonFNALSimHit(void *p = 0);
   static void *newArray_mu2ecLcLExtMonFNALSimHit(Long_t size, void *p);
   static void delete_mu2ecLcLExtMonFNALSimHit(void *p);
   static void deleteArray_mu2ecLcLExtMonFNALSimHit(void *p);
   static void destruct_mu2ecLcLExtMonFNALSimHit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ExtMonFNALSimHit*)
   {
      ::mu2e::ExtMonFNALSimHit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ExtMonFNALSimHit));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ExtMonFNALSimHit", "MCDataProducts/inc/ExtMonFNALSimHit.hh", 26,
                  typeid(::mu2e::ExtMonFNALSimHit), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLExtMonFNALSimHit_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ExtMonFNALSimHit) );
      instance.SetNew(&new_mu2ecLcLExtMonFNALSimHit);
      instance.SetNewArray(&newArray_mu2ecLcLExtMonFNALSimHit);
      instance.SetDelete(&delete_mu2ecLcLExtMonFNALSimHit);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLExtMonFNALSimHit);
      instance.SetDestructor(&destruct_mu2ecLcLExtMonFNALSimHit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ExtMonFNALSimHit*)
   {
      return GenerateInitInstanceLocal((::mu2e::ExtMonFNALSimHit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALSimHit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLExtMonFNALSimHit_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALSimHit*)0x0)->GetClass();
      mu2ecLcLExtMonFNALSimHit_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLExtMonFNALSimHit_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLExtMonFNALHitTruthBits_Dictionary();
   static void mu2ecLcLExtMonFNALHitTruthBits_TClassManip(TClass*);
   static void *new_mu2ecLcLExtMonFNALHitTruthBits(void *p = 0);
   static void *newArray_mu2ecLcLExtMonFNALHitTruthBits(Long_t size, void *p);
   static void delete_mu2ecLcLExtMonFNALHitTruthBits(void *p);
   static void deleteArray_mu2ecLcLExtMonFNALHitTruthBits(void *p);
   static void destruct_mu2ecLcLExtMonFNALHitTruthBits(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ExtMonFNALHitTruthBits*)
   {
      ::mu2e::ExtMonFNALHitTruthBits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ExtMonFNALHitTruthBits));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ExtMonFNALHitTruthBits", "MCDataProducts/inc/ExtMonFNALHitTruthAssn.hh", 21,
                  typeid(::mu2e::ExtMonFNALHitTruthBits), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLExtMonFNALHitTruthBits_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ExtMonFNALHitTruthBits) );
      instance.SetNew(&new_mu2ecLcLExtMonFNALHitTruthBits);
      instance.SetNewArray(&newArray_mu2ecLcLExtMonFNALHitTruthBits);
      instance.SetDelete(&delete_mu2ecLcLExtMonFNALHitTruthBits);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLExtMonFNALHitTruthBits);
      instance.SetDestructor(&destruct_mu2ecLcLExtMonFNALHitTruthBits);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ExtMonFNALHitTruthBits*)
   {
      return GenerateInitInstanceLocal((::mu2e::ExtMonFNALHitTruthBits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALHitTruthBits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLExtMonFNALHitTruthBits_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALHitTruthBits*)0x0)->GetClass();
      mu2ecLcLExtMonFNALHitTruthBits_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLExtMonFNALHitTruthBits_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLExtMonFNALRecoClusterTruthBits_Dictionary();
   static void mu2ecLcLExtMonFNALRecoClusterTruthBits_TClassManip(TClass*);
   static void *new_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p = 0);
   static void *newArray_mu2ecLcLExtMonFNALRecoClusterTruthBits(Long_t size, void *p);
   static void delete_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p);
   static void deleteArray_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p);
   static void destruct_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ExtMonFNALRecoClusterTruthBits*)
   {
      ::mu2e::ExtMonFNALRecoClusterTruthBits *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ExtMonFNALRecoClusterTruthBits));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ExtMonFNALRecoClusterTruthBits", "MCDataProducts/inc/ExtMonFNALRecoClusterTruthAssn.hh", 21,
                  typeid(::mu2e::ExtMonFNALRecoClusterTruthBits), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLExtMonFNALRecoClusterTruthBits_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ExtMonFNALRecoClusterTruthBits) );
      instance.SetNew(&new_mu2ecLcLExtMonFNALRecoClusterTruthBits);
      instance.SetNewArray(&newArray_mu2ecLcLExtMonFNALRecoClusterTruthBits);
      instance.SetDelete(&delete_mu2ecLcLExtMonFNALRecoClusterTruthBits);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLExtMonFNALRecoClusterTruthBits);
      instance.SetDestructor(&destruct_mu2ecLcLExtMonFNALRecoClusterTruthBits);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ExtMonFNALRecoClusterTruthBits*)
   {
      return GenerateInitInstanceLocal((::mu2e::ExtMonFNALRecoClusterTruthBits*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALRecoClusterTruthBits*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLExtMonFNALRecoClusterTruthBits_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALRecoClusterTruthBits*)0x0)->GetClass();
      mu2ecLcLExtMonFNALRecoClusterTruthBits_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLExtMonFNALRecoClusterTruthBits_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLExtMonFNALTrkMatchInfo_Dictionary();
   static void mu2ecLcLExtMonFNALTrkMatchInfo_TClassManip(TClass*);
   static void *new_mu2ecLcLExtMonFNALTrkMatchInfo(void *p = 0);
   static void *newArray_mu2ecLcLExtMonFNALTrkMatchInfo(Long_t size, void *p);
   static void delete_mu2ecLcLExtMonFNALTrkMatchInfo(void *p);
   static void deleteArray_mu2ecLcLExtMonFNALTrkMatchInfo(void *p);
   static void destruct_mu2ecLcLExtMonFNALTrkMatchInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ExtMonFNALTrkMatchInfo*)
   {
      ::mu2e::ExtMonFNALTrkMatchInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ExtMonFNALTrkMatchInfo));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ExtMonFNALTrkMatchInfo", "MCDataProducts/inc/ExtMonFNALPatRecTruthAssns.hh", 22,
                  typeid(::mu2e::ExtMonFNALTrkMatchInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLExtMonFNALTrkMatchInfo_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ExtMonFNALTrkMatchInfo) );
      instance.SetNew(&new_mu2ecLcLExtMonFNALTrkMatchInfo);
      instance.SetNewArray(&newArray_mu2ecLcLExtMonFNALTrkMatchInfo);
      instance.SetDelete(&delete_mu2ecLcLExtMonFNALTrkMatchInfo);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLExtMonFNALTrkMatchInfo);
      instance.SetDestructor(&destruct_mu2ecLcLExtMonFNALTrkMatchInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ExtMonFNALTrkMatchInfo*)
   {
      return GenerateInitInstanceLocal((::mu2e::ExtMonFNALTrkMatchInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALTrkMatchInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLExtMonFNALTrkMatchInfo_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ExtMonFNALTrkMatchInfo*)0x0)->GetClass();
      mu2ecLcLExtMonFNALTrkMatchInfo_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLExtMonFNALTrkMatchInfo_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLMARSInfo_Dictionary();
   static void mu2ecLcLMARSInfo_TClassManip(TClass*);
   static void *new_mu2ecLcLMARSInfo(void *p = 0);
   static void *newArray_mu2ecLcLMARSInfo(Long_t size, void *p);
   static void delete_mu2ecLcLMARSInfo(void *p);
   static void deleteArray_mu2ecLcLMARSInfo(void *p);
   static void destruct_mu2ecLcLMARSInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::MARSInfo*)
   {
      ::mu2e::MARSInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::MARSInfo));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::MARSInfo", "MCDataProducts/inc/MARSInfo.hh", 10,
                  typeid(::mu2e::MARSInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLMARSInfo_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::MARSInfo) );
      instance.SetNew(&new_mu2ecLcLMARSInfo);
      instance.SetNewArray(&newArray_mu2ecLcLMARSInfo);
      instance.SetDelete(&delete_mu2ecLcLMARSInfo);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLMARSInfo);
      instance.SetDestructor(&destruct_mu2ecLcLMARSInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::MARSInfo*)
   {
      return GenerateInitInstanceLocal((::mu2e::MARSInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::MARSInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLMARSInfo_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::MARSInfo*)0x0)->GetClass();
      mu2ecLcLMARSInfo_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLMARSInfo_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLStepFilterMode_Dictionary();
   static void mu2ecLcLStepFilterMode_TClassManip(TClass*);
   static void *new_mu2ecLcLStepFilterMode(void *p = 0);
   static void *newArray_mu2ecLcLStepFilterMode(Long_t size, void *p);
   static void delete_mu2ecLcLStepFilterMode(void *p);
   static void deleteArray_mu2ecLcLStepFilterMode(void *p);
   static void destruct_mu2ecLcLStepFilterMode(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::StepFilterMode*)
   {
      ::mu2e::StepFilterMode *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::StepFilterMode));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::StepFilterMode", "MCDataProducts/inc/StepFilterMode.hh", 34,
                  typeid(::mu2e::StepFilterMode), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLStepFilterMode_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::StepFilterMode) );
      instance.SetNew(&new_mu2ecLcLStepFilterMode);
      instance.SetNewArray(&newArray_mu2ecLcLStepFilterMode);
      instance.SetDelete(&delete_mu2ecLcLStepFilterMode);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLStepFilterMode);
      instance.SetDestructor(&destruct_mu2ecLcLStepFilterMode);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::StepFilterMode*)
   {
      return GenerateInitInstanceLocal((::mu2e::StepFilterMode*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::StepFilterMode*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLStepFilterMode_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::StepFilterMode*)0x0)->GetClass();
      mu2ecLcLStepFilterMode_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLStepFilterMode_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLGenEventCount_Dictionary();
   static void mu2ecLcLGenEventCount_TClassManip(TClass*);
   static void *new_mu2ecLcLGenEventCount(void *p = 0);
   static void *newArray_mu2ecLcLGenEventCount(Long_t size, void *p);
   static void delete_mu2ecLcLGenEventCount(void *p);
   static void deleteArray_mu2ecLcLGenEventCount(void *p);
   static void destruct_mu2ecLcLGenEventCount(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::GenEventCount*)
   {
      ::mu2e::GenEventCount *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::GenEventCount));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::GenEventCount", "MCDataProducts/inc/GenEventCount.hh", 13,
                  typeid(::mu2e::GenEventCount), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLGenEventCount_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::GenEventCount) );
      instance.SetNew(&new_mu2ecLcLGenEventCount);
      instance.SetNewArray(&newArray_mu2ecLcLGenEventCount);
      instance.SetDelete(&delete_mu2ecLcLGenEventCount);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLGenEventCount);
      instance.SetDestructor(&destruct_mu2ecLcLGenEventCount);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::GenEventCount*)
   {
      return GenerateInitInstanceLocal((::mu2e::GenEventCount*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::GenEventCount*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLGenEventCount_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::GenEventCount*)0x0)->GetClass();
      mu2ecLcLGenEventCount_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLGenEventCount_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLEventWeight_Dictionary();
   static void mu2ecLcLEventWeight_TClassManip(TClass*);
   static void *new_mu2ecLcLEventWeight(void *p = 0);
   static void *newArray_mu2ecLcLEventWeight(Long_t size, void *p);
   static void delete_mu2ecLcLEventWeight(void *p);
   static void deleteArray_mu2ecLcLEventWeight(void *p);
   static void destruct_mu2ecLcLEventWeight(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::EventWeight*)
   {
      ::mu2e::EventWeight *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::EventWeight));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::EventWeight", "MCDataProducts/inc/EventWeight.hh", 8,
                  typeid(::mu2e::EventWeight), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLEventWeight_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::EventWeight) );
      instance.SetNew(&new_mu2ecLcLEventWeight);
      instance.SetNewArray(&newArray_mu2ecLcLEventWeight);
      instance.SetDelete(&delete_mu2ecLcLEventWeight);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLEventWeight);
      instance.SetDestructor(&destruct_mu2ecLcLEventWeight);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::EventWeight*)
   {
      return GenerateInitInstanceLocal((::mu2e::EventWeight*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::EventWeight*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLEventWeight_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::EventWeight*)0x0)->GetClass();
      mu2ecLcLEventWeight_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLEventWeight_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLTrackSummaryMatchInfo_Dictionary();
   static void mu2ecLcLTrackSummaryMatchInfo_TClassManip(TClass*);
   static void *new_mu2ecLcLTrackSummaryMatchInfo(void *p = 0);
   static void *newArray_mu2ecLcLTrackSummaryMatchInfo(Long_t size, void *p);
   static void delete_mu2ecLcLTrackSummaryMatchInfo(void *p);
   static void deleteArray_mu2ecLcLTrackSummaryMatchInfo(void *p);
   static void destruct_mu2ecLcLTrackSummaryMatchInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::TrackSummaryMatchInfo*)
   {
      ::mu2e::TrackSummaryMatchInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::TrackSummaryMatchInfo));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::TrackSummaryMatchInfo", "MCDataProducts/inc/TrackSummaryTruthAssns.hh", 21,
                  typeid(::mu2e::TrackSummaryMatchInfo), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLTrackSummaryMatchInfo_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::TrackSummaryMatchInfo) );
      instance.SetNew(&new_mu2ecLcLTrackSummaryMatchInfo);
      instance.SetNewArray(&newArray_mu2ecLcLTrackSummaryMatchInfo);
      instance.SetDelete(&delete_mu2ecLcLTrackSummaryMatchInfo);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLTrackSummaryMatchInfo);
      instance.SetDestructor(&destruct_mu2ecLcLTrackSummaryMatchInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::TrackSummaryMatchInfo*)
   {
      return GenerateInitInstanceLocal((::mu2e::TrackSummaryMatchInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::TrackSummaryMatchInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLTrackSummaryMatchInfo_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::TrackSummaryMatchInfo*)0x0)->GetClass();
      mu2ecLcLTrackSummaryMatchInfo_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLTrackSummaryMatchInfo_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLSimParticleTrackerHitSummary_Dictionary();
   static void mu2ecLcLSimParticleTrackerHitSummary_TClassManip(TClass*);
   static void *new_mu2ecLcLSimParticleTrackerHitSummary(void *p = 0);
   static void *newArray_mu2ecLcLSimParticleTrackerHitSummary(Long_t size, void *p);
   static void delete_mu2ecLcLSimParticleTrackerHitSummary(void *p);
   static void deleteArray_mu2ecLcLSimParticleTrackerHitSummary(void *p);
   static void destruct_mu2ecLcLSimParticleTrackerHitSummary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::SimParticleTrackerHitSummary*)
   {
      ::mu2e::SimParticleTrackerHitSummary *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::SimParticleTrackerHitSummary));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::SimParticleTrackerHitSummary", "MCDataProducts/inc/SimParticleTrackerHitSummaryCollection.hh", 12,
                  typeid(::mu2e::SimParticleTrackerHitSummary), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLSimParticleTrackerHitSummary_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::SimParticleTrackerHitSummary) );
      instance.SetNew(&new_mu2ecLcLSimParticleTrackerHitSummary);
      instance.SetNewArray(&newArray_mu2ecLcLSimParticleTrackerHitSummary);
      instance.SetDelete(&delete_mu2ecLcLSimParticleTrackerHitSummary);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLSimParticleTrackerHitSummary);
      instance.SetDestructor(&destruct_mu2ecLcLSimParticleTrackerHitSummary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::SimParticleTrackerHitSummary*)
   {
      return GenerateInitInstanceLocal((::mu2e::SimParticleTrackerHitSummary*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::SimParticleTrackerHitSummary*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLSimParticleTrackerHitSummary_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::SimParticleTrackerHitSummary*)0x0)->GetClass();
      mu2ecLcLSimParticleTrackerHitSummary_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLSimParticleTrackerHitSummary_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *mu2ecLcLProtonBunchIntensity_Dictionary();
   static void mu2ecLcLProtonBunchIntensity_TClassManip(TClass*);
   static void *new_mu2ecLcLProtonBunchIntensity(void *p = 0);
   static void *newArray_mu2ecLcLProtonBunchIntensity(Long_t size, void *p);
   static void delete_mu2ecLcLProtonBunchIntensity(void *p);
   static void deleteArray_mu2ecLcLProtonBunchIntensity(void *p);
   static void destruct_mu2ecLcLProtonBunchIntensity(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mu2e::ProtonBunchIntensity*)
   {
      ::mu2e::ProtonBunchIntensity *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::mu2e::ProtonBunchIntensity));
      static ::ROOT::TGenericClassInfo 
         instance("mu2e::ProtonBunchIntensity", "MCDataProducts/inc/ProtonBunchIntensity.hh", 11,
                  typeid(::mu2e::ProtonBunchIntensity), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &mu2ecLcLProtonBunchIntensity_Dictionary, isa_proxy, 4,
                  sizeof(::mu2e::ProtonBunchIntensity) );
      instance.SetNew(&new_mu2ecLcLProtonBunchIntensity);
      instance.SetNewArray(&newArray_mu2ecLcLProtonBunchIntensity);
      instance.SetDelete(&delete_mu2ecLcLProtonBunchIntensity);
      instance.SetDeleteArray(&deleteArray_mu2ecLcLProtonBunchIntensity);
      instance.SetDestructor(&destruct_mu2ecLcLProtonBunchIntensity);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mu2e::ProtonBunchIntensity*)
   {
      return GenerateInitInstanceLocal((::mu2e::ProtonBunchIntensity*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mu2e::ProtonBunchIntensity*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *mu2ecLcLProtonBunchIntensity_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::mu2e::ProtonBunchIntensity*)0x0)->GetClass();
      mu2ecLcLProtonBunchIntensity_TClassManip(theClass);
   return theClass;
   }

   static void mu2ecLcLProtonBunchIntensity_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > : new pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >;
   }
   static void *newArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >[nElements] : new pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete ((pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void deleteArray_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete [] ((pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void destruct_pairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      typedef pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::SimParticle> : new pair<cet::map_vector_key,mu2e::SimParticle>;
   }
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::SimParticle>[nElements] : new pair<cet::map_vector_key,mu2e::SimParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p) {
      delete ((pair<cet::map_vector_key,mu2e::SimParticle>*)p);
   }
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p) {
      delete [] ((pair<cet::map_vector_key,mu2e::SimParticle>*)p);
   }
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegR(void *p) {
      typedef pair<cet::map_vector_key,mu2e::SimParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<cet::map_vector_key,mu2e::SimParticle>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector> : new pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>;
   }
   static void *newArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>[nElements] : new pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p) {
      delete ((pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>*)p);
   }
   static void deleteArray_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p) {
      delete [] ((pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>*)p);
   }
   static void destruct_pairlECLHEPcLcLHep3VectorcOCLHEPcLcLHepLorentzVectorgR(void *p) {
      typedef pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<CLHEP::Hep3Vector,CLHEP::HepLorentzVector>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>;
   }
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>[nElements] : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      delete ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)p);
   }
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      delete [] ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)p);
   }
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      typedef pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>;
   }
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>[nElements] : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      delete ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)p);
   }
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      delete [] ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)p);
   }
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      typedef pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>;
   }
   static void *newArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>[nElements] : new pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      delete ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)p);
   }
   static void deleteArray_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      delete [] ((pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)p);
   }
   static void destruct_pairlEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      typedef pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticleTrackerHitSummary>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticleTrackerHitSummarygRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticleTrackerHitSummary> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLTrackSummarygRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::TrackSummary>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLTrackSummarygRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::TrackSummary> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::ExtMonFNALTrkFit>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALTrkFitgRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALTrkFit> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::ExtMonFNALRecoCluster>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRecoClustergRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRecoCluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::ExtMonFNALRawHit>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLExtMonFNALRawHitgRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::ExtMonFNALRawHit> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,double> : new pair<art::Ptr<mu2e::SimParticle>,double>;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,double>[nElements] : new pair<art::Ptr<mu2e::SimParticle>,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,double>*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,double>*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> > : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >[nElements] : new pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::MARSInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> > : new pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >[nElements] : new pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> > : new pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >[nElements] : new pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLGenParticlegRcOartcLcLPtrlEmu2ecLcLMARSInfogRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::GenParticle>,art::Ptr<mu2e::MARSInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> > : new pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >[nElements] : new pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p) {
      delete ((pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLMARSInfogRcOartcLcLPtrlEmu2ecLcLGenParticlegRsPgR(void *p) {
      typedef pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::MARSInfo>,art::Ptr<mu2e::GenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::PointTrajectory> : new pair<cet::map_vector_key,mu2e::PointTrajectory>;
   }
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::PointTrajectory>[nElements] : new pair<cet::map_vector_key,mu2e::PointTrajectory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p) {
      delete ((pair<cet::map_vector_key,mu2e::PointTrajectory>*)p);
   }
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p) {
      delete [] ((pair<cet::map_vector_key,mu2e::PointTrajectory>*)p);
   }
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygR(void *p) {
      typedef pair<cet::map_vector_key,mu2e::PointTrajectory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<cet::map_vector_key,mu2e::PointTrajectory>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> : new pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>;
   }
   static void *newArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>[nElements] : new pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      delete ((pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)p);
   }
   static void deleteArray_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      delete [] ((pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)p);
   }
   static void destruct_pairlEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      typedef pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> : new pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>;
   }
   static void *newArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>[nElements] : new pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete ((pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>*)p);
   }
   static void deleteArray_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete [] ((pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>*)p);
   }
   static void destruct_pairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogR(void *p) {
      typedef pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > : new ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >[nElements] : new ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > : new ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >[nElements] : new ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> : new ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>[nElements] : new ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> : new ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> : new ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>[nElements] : new ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> : new ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> : new ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> : new ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> : new ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> : new ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> : new ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> : new ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>[nElements] : new ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete ((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete [] ((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      typedef ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void> : new ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void> : new ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> : new ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>[nElements] : new ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> : new ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> : new ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>[nElements] : new ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> : new ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> : new ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>[nElements] : new ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> : new ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>[nElements] : new ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>;
   }
   static void *newArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>[nElements] : new ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p) {
      delete ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)p);
   }
   static void deleteArray_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p) {
      delete [] ((::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>*)p);
   }
   static void destruct_artcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgR(void *p) {
      typedef ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloDigi> : new ::art::Ptr<mu2e::CaloDigi>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloDigigR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloDigi>[nElements] : new ::art::Ptr<mu2e::CaloDigi>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p) {
      delete ((::art::Ptr<mu2e::CaloDigi>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p) {
      delete [] ((::art::Ptr<mu2e::CaloDigi>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLCaloDigigR(void *p) {
      typedef ::art::Ptr<mu2e::CaloDigi> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::CaloDigi>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::SimParticle> : new ::art::Ptr<mu2e::SimParticle>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLSimParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::SimParticle>[nElements] : new ::art::Ptr<mu2e::SimParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p) {
      delete ((::art::Ptr<mu2e::SimParticle>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p) {
      delete [] ((::art::Ptr<mu2e::SimParticle>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLSimParticlegR(void *p) {
      typedef ::art::Ptr<mu2e::SimParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::SimParticle>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::GenParticle> : new ::art::Ptr<mu2e::GenParticle>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLGenParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::GenParticle>[nElements] : new ::art::Ptr<mu2e::GenParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p) {
      delete ((::art::Ptr<mu2e::GenParticle>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p) {
      delete [] ((::art::Ptr<mu2e::GenParticle>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLGenParticlegR(void *p) {
      typedef ::art::Ptr<mu2e::GenParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::GenParticle>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloShowerStep> : new ::art::Ptr<mu2e::CaloShowerStep>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloShowerStep>[nElements] : new ::art::Ptr<mu2e::CaloShowerStep>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p) {
      delete ((::art::Ptr<mu2e::CaloShowerStep>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p) {
      delete [] ((::art::Ptr<mu2e::CaloShowerStep>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLCaloShowerStepgR(void *p) {
      typedef ::art::Ptr<mu2e::CaloShowerStep> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::CaloShowerStep>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloShowerSim> : new ::art::Ptr<mu2e::CaloShowerSim>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::CaloShowerSim>[nElements] : new ::art::Ptr<mu2e::CaloShowerSim>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p) {
      delete ((::art::Ptr<mu2e::CaloShowerSim>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p) {
      delete [] ((::art::Ptr<mu2e::CaloShowerSim>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLCaloShowerSimgR(void *p) {
      typedef ::art::Ptr<mu2e::CaloShowerSim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::CaloShowerSim>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::StepPointMC> : new ::art::Ptr<mu2e::StepPointMC>;
   }
   static void *newArray_artcLcLPtrlEmu2ecLcLStepPointMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Ptr<mu2e::StepPointMC>[nElements] : new ::art::Ptr<mu2e::StepPointMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p) {
      delete ((::art::Ptr<mu2e::StepPointMC>*)p);
   }
   static void deleteArray_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p) {
      delete [] ((::art::Ptr<mu2e::StepPointMC>*)p);
   }
   static void destruct_artcLcLPtrlEmu2ecLcLStepPointMCgR(void *p) {
      typedef ::art::Ptr<mu2e::StepPointMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Ptr<mu2e::StepPointMC>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::ProtonBunchIntensity> : new ::art::Wrapper<mu2e::ProtonBunchIntensity>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::ProtonBunchIntensity>[nElements] : new ::art::Wrapper<mu2e::ProtonBunchIntensity>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p) {
      delete ((::art::Wrapper<mu2e::ProtonBunchIntensity>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p) {
      delete [] ((::art::Wrapper<mu2e::ProtonBunchIntensity>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLProtonBunchIntensitygR(void *p) {
      typedef ::art::Wrapper<mu2e::ProtonBunchIntensity> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::ProtonBunchIntensity>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> > : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >;
   }
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >[nElements] : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p) {
      delete ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgRsPgR(void *p) {
      typedef ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> > : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >;
   }
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >[nElements] : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p) {
      delete ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgRsPgR(void *p) {
      typedef ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> > : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >;
   }
   static void *newArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >[nElements] : new ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p) {
      delete ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgRsPgR(void *p) {
      typedef ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloClustercOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > : new ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >[nElements] : new ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloClustercOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLCaloCrystalHitcOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > : new ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >[nElements] : new ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLCaloCrystalHitcOmu2ecLcLSimParticlecOartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticleTrackerHitSummarycOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLSimParticleTrackerHitSummarycOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> > : new ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLTrackSummarycOmu2ecLcLSimParticlecOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLTrackSummarycOmu2ecLcLTrackSummaryMatchInfogRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::EventWeight> : new ::art::Wrapper<mu2e::EventWeight>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLEventWeightgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::EventWeight>[nElements] : new ::art::Wrapper<mu2e::EventWeight>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p) {
      delete ((::art::Wrapper<mu2e::EventWeight>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p) {
      delete [] ((::art::Wrapper<mu2e::EventWeight>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLEventWeightgR(void *p) {
      typedef ::art::Wrapper<mu2e::EventWeight> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::EventWeight>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > > : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >;
   }
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >[nElements] : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::GenEventCount> : new ::art::Wrapper<mu2e::GenEventCount>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::GenEventCount>[nElements] : new ::art::Wrapper<mu2e::GenEventCount>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p) {
      delete ((::art::Wrapper<mu2e::GenEventCount>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p) {
      delete [] ((::art::Wrapper<mu2e::GenEventCount>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLGenEventCountgR(void *p) {
      typedef ::art::Wrapper<mu2e::GenEventCount> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::GenEventCount>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > > : new ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >[nElements] : new ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLExtMonFNALTrkMatchInfogRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALTrkFitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALTrkFitcOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLExtMonFNALRecoClusterTruthBitsgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRecoClustercOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRecoClustercOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOmu2ecLcLExtMonFNALHitTruthBitsgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLExtMonFNALRawHitcOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLExtMonFNALRawHitcOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> > : new ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >[nElements] : new ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonFNALSimHitgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> > : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >;
   }
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >[nElements] : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p) {
      delete ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegRsPgR(void *p) {
      typedef ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> > : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLSimParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> > : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLMARSInfocOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::MARSInfo> > : new ::art::Wrapper<vector<mu2e::MARSInfo> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::MARSInfo> >[nElements] : new ::art::Wrapper<vector<mu2e::MARSInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::MARSInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::MARSInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLMARSInfogRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::MARSInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::MARSInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> > : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLSimParticlecOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> > : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >;
   }
   static void *newArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >[nElements] : new ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p) {
      delete ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p) {
      delete [] ((::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >*)p);
   }
   static void destruct_artcLcLWrapperlEartcLcLAssnslEmu2ecLcLGenParticlecOmu2ecLcLStepPointMCcOvoidgRsPgR(void *p) {
      typedef ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::VisibleGenElTrack> > : new ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >[nElements] : new ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::VisibleGenElTrack> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLVisibleGenElTrackgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::VisibleGenElTrack> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::VisibleGenElTrack> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::MixingSummary> : new ::art::Wrapper<mu2e::MixingSummary>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::MixingSummary>[nElements] : new ::art::Wrapper<mu2e::MixingSummary>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p) {
      delete ((::art::Wrapper<mu2e::MixingSummary>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p) {
      delete [] ((::art::Wrapper<mu2e::MixingSummary>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLMixingSummarygR(void *p) {
      typedef ::art::Wrapper<mu2e::MixingSummary> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::MixingSummary>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > > : new ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >[nElements] : new ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::StatusG4> : new ::art::Wrapper<mu2e::StatusG4>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLStatusG4gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::StatusG4>[nElements] : new ::art::Wrapper<mu2e::StatusG4>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p) {
      delete ((::art::Wrapper<mu2e::StatusG4>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p) {
      delete [] ((::art::Wrapper<mu2e::StatusG4>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLStatusG4gR(void *p) {
      typedef ::art::Wrapper<mu2e::StatusG4> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::StatusG4>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> > : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >;
   }
   static void *newArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >[nElements] : new ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p) {
      delete ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p) {
      delete [] ((::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >*)p);
   }
   static void destruct_artcLcLWrapperlEmaplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygRsPgR(void *p) {
      typedef ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> > : new ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >;
   }
   static void *newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >[nElements] : new ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p) {
      delete ((::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p) {
      delete [] ((::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >*)p);
   }
   static void destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLPointTrajectorygRsPgR(void *p) {
      typedef ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> > : new ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >[nElements] : new ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLExtMonUCITofHitMCTruthgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloDigi> > : new ::art::Wrapper<vector<mu2e::CaloDigi> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloDigi> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloDigi> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloDigi> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigigRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloDigi> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> > : new ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitSimPartMCgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloHitSimPartMC> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloDigiMC> > : new ::art::Wrapper<vector<mu2e::CaloDigiMC> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloDigiMC> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloDigiMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloDigiMC> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloDigiMC> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloDigiMCgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloDigiMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloDigiMC> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloHitMCTruth> > : new ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloHitMCTruth> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloHitMCTruthgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloHitMCTruth> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloHitMCTruth> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerSim> > : new ::art::Wrapper<vector<mu2e::CaloShowerSim> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerSim> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloShowerSim> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerStepRO> > : new ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloShowerStepRO> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepROgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloShowerStepRO> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloShowerStepRO> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerStep> > : new ::art::Wrapper<vector<mu2e::CaloShowerStep> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::CaloShowerStep> >[nElements] : new ::art::Wrapper<vector<mu2e::CaloShowerStep> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::CaloShowerStep> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::CaloShowerStep> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::CaloShowerStep> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::CaloShowerStep> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::G4BeamlineInfo> > : new ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >[nElements] : new ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::G4BeamlineInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLG4BeamlineInfogRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::G4BeamlineInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::G4BeamlineInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::G4BeamlineInfo> : new ::art::Wrapper<mu2e::G4BeamlineInfo>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::G4BeamlineInfo>[nElements] : new ::art::Wrapper<mu2e::G4BeamlineInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p) {
      delete ((::art::Wrapper<mu2e::G4BeamlineInfo>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p) {
      delete [] ((::art::Wrapper<mu2e::G4BeamlineInfo>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLG4BeamlineInfogR(void *p) {
      typedef ::art::Wrapper<mu2e::G4BeamlineInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::G4BeamlineInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StrawDigiMC> > : new ::art::Wrapper<vector<mu2e::StrawDigiMC> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StrawDigiMC> >[nElements] : new ::art::Wrapper<vector<mu2e::StrawDigiMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::StrawDigiMC> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::StrawDigiMC> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawDigiMCgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::StrawDigiMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::StrawDigiMC> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StrawHitMCTruth> > : new ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >[nElements] : new ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::StrawHitMCTruth> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStrawHitMCTruthgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::StrawHitMCTruth> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::StrawHitMCTruth> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<cet::map_vector<mu2e::SimParticle> > : new ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >;
   }
   static void *newArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >[nElements] : new ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((::art::Wrapper<cet::map_vector<mu2e::SimParticle> >*)p);
   }
   static void destruct_artcLcLWrapperlEcetcLcLmap_vectorlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef ::art::Wrapper<cet::map_vector<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<cet::map_vector<mu2e::SimParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > > : new ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >[nElements] : new ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> > : new ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >[nElements] : new ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StepPointMC> > : new ::art::Wrapper<vector<mu2e::StepPointMC> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::StepPointMC> >[nElements] : new ::art::Wrapper<vector<mu2e::StepPointMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::StepPointMC> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::StepPointMC> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::StepPointMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::StepPointMC> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::GenParticle> > : new ::art::Wrapper<vector<mu2e::GenParticle> >;
   }
   static void *newArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<vector<mu2e::GenParticle> >[nElements] : new ::art::Wrapper<vector<mu2e::GenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p) {
      delete ((::art::Wrapper<vector<mu2e::GenParticle> >*)p);
   }
   static void deleteArray_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p) {
      delete [] ((::art::Wrapper<vector<mu2e::GenParticle> >*)p);
   }
   static void destruct_artcLcLWrapperlEvectorlEmu2ecLcLGenParticlegRsPgR(void *p) {
      typedef ::art::Wrapper<vector<mu2e::GenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<vector<mu2e::GenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::CaloDigi> : new ::art::Wrapper<mu2e::CaloDigi>;
   }
   static void *newArray_artcLcLWrapperlEmu2ecLcLCaloDigigR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::art::Wrapper<mu2e::CaloDigi>[nElements] : new ::art::Wrapper<mu2e::CaloDigi>[nElements];
   }
   // Wrapper around operator delete
   static void delete_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p) {
      delete ((::art::Wrapper<mu2e::CaloDigi>*)p);
   }
   static void deleteArray_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p) {
      delete [] ((::art::Wrapper<mu2e::CaloDigi>*)p);
   }
   static void destruct_artcLcLWrapperlEmu2ecLcLCaloDigigR(void *p) {
      typedef ::art::Wrapper<mu2e::CaloDigi> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::art::Wrapper<mu2e::CaloDigi>

namespace ROOT {
   // Wrappers around operator new
   static void *new_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::SimParticle> : new ::cet::map_vector<mu2e::SimParticle>;
   }
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::SimParticle>[nElements] : new ::cet::map_vector<mu2e::SimParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p) {
      delete ((::cet::map_vector<mu2e::SimParticle>*)p);
   }
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p) {
      delete [] ((::cet::map_vector<mu2e::SimParticle>*)p);
   }
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLSimParticlegR(void *p) {
      typedef ::cet::map_vector<mu2e::SimParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::cet::map_vector<mu2e::SimParticle>

namespace ROOT {
   // Wrappers around operator new
   static void *new_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::PhysicalVolumeInfo> : new ::cet::map_vector<mu2e::PhysicalVolumeInfo>;
   }
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::PhysicalVolumeInfo>[nElements] : new ::cet::map_vector<mu2e::PhysicalVolumeInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete ((::cet::map_vector<mu2e::PhysicalVolumeInfo>*)p);
   }
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete [] ((::cet::map_vector<mu2e::PhysicalVolumeInfo>*)p);
   }
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      typedef ::cet::map_vector<mu2e::PhysicalVolumeInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::cet::map_vector<mu2e::PhysicalVolumeInfo>

namespace ROOT {
   // Wrappers around operator new
   static void *new_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::PointTrajectory> : new ::cet::map_vector<mu2e::PointTrajectory>;
   }
   static void *newArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::cet::map_vector<mu2e::PointTrajectory>[nElements] : new ::cet::map_vector<mu2e::PointTrajectory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p) {
      delete ((::cet::map_vector<mu2e::PointTrajectory>*)p);
   }
   static void deleteArray_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p) {
      delete [] ((::cet::map_vector<mu2e::PointTrajectory>*)p);
   }
   static void destruct_cetcLcLmap_vectorlEmu2ecLcLPointTrajectorygR(void *p) {
      typedef ::cet::map_vector<mu2e::PointTrajectory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::cet::map_vector<mu2e::PointTrajectory>

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloDigi(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloDigi : new ::mu2e::CaloDigi;
   }
   static void *newArray_mu2ecLcLCaloDigi(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloDigi[nElements] : new ::mu2e::CaloDigi[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloDigi(void *p) {
      delete ((::mu2e::CaloDigi*)p);
   }
   static void deleteArray_mu2ecLcLCaloDigi(void *p) {
      delete [] ((::mu2e::CaloDigi*)p);
   }
   static void destruct_mu2ecLcLCaloDigi(void *p) {
      typedef ::mu2e::CaloDigi current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloDigi

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLPDGCode(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PDGCode : new ::mu2e::PDGCode;
   }
   static void *newArray_mu2ecLcLPDGCode(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PDGCode[nElements] : new ::mu2e::PDGCode[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLPDGCode(void *p) {
      delete ((::mu2e::PDGCode*)p);
   }
   static void deleteArray_mu2ecLcLPDGCode(void *p) {
      delete [] ((::mu2e::PDGCode*)p);
   }
   static void destruct_mu2ecLcLPDGCode(void *p) {
      typedef ::mu2e::PDGCode current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::PDGCode

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLGenId(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenId : new ::mu2e::GenId;
   }
   static void *newArray_mu2ecLcLGenId(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenId[nElements] : new ::mu2e::GenId[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLGenId(void *p) {
      delete ((::mu2e::GenId*)p);
   }
   static void deleteArray_mu2ecLcLGenId(void *p) {
      delete [] ((::mu2e::GenId*)p);
   }
   static void destruct_mu2ecLcLGenId(void *p) {
      typedef ::mu2e::GenId current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::GenId

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLGenParticle(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenParticle : new ::mu2e::GenParticle;
   }
   static void *newArray_mu2ecLcLGenParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenParticle[nElements] : new ::mu2e::GenParticle[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLGenParticle(void *p) {
      delete ((::mu2e::GenParticle*)p);
   }
   static void deleteArray_mu2ecLcLGenParticle(void *p) {
      delete [] ((::mu2e::GenParticle*)p);
   }
   static void destruct_mu2ecLcLGenParticle(void *p) {
      typedef ::mu2e::GenParticle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::GenParticle

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLProcessCode(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ProcessCode : new ::mu2e::ProcessCode;
   }
   static void *newArray_mu2ecLcLProcessCode(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ProcessCode[nElements] : new ::mu2e::ProcessCode[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLProcessCode(void *p) {
      delete ((::mu2e::ProcessCode*)p);
   }
   static void deleteArray_mu2ecLcLProcessCode(void *p) {
      delete [] ((::mu2e::ProcessCode*)p);
   }
   static void destruct_mu2ecLcLProcessCode(void *p) {
      typedef ::mu2e::ProcessCode current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ProcessCode

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLSimParticle(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::SimParticle : new ::mu2e::SimParticle;
   }
   static void *newArray_mu2ecLcLSimParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::SimParticle[nElements] : new ::mu2e::SimParticle[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLSimParticle(void *p) {
      delete ((::mu2e::SimParticle*)p);
   }
   static void deleteArray_mu2ecLcLSimParticle(void *p) {
      delete [] ((::mu2e::SimParticle*)p);
   }
   static void destruct_mu2ecLcLSimParticle(void *p) {
      typedef ::mu2e::SimParticle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::SimParticle

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloShowerStep(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerStep : new ::mu2e::CaloShowerStep;
   }
   static void *newArray_mu2ecLcLCaloShowerStep(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerStep[nElements] : new ::mu2e::CaloShowerStep[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloShowerStep(void *p) {
      delete ((::mu2e::CaloShowerStep*)p);
   }
   static void deleteArray_mu2ecLcLCaloShowerStep(void *p) {
      delete [] ((::mu2e::CaloShowerStep*)p);
   }
   static void destruct_mu2ecLcLCaloShowerStep(void *p) {
      typedef ::mu2e::CaloShowerStep current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloShowerStep

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloShowerSim(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerSim : new ::mu2e::CaloShowerSim;
   }
   static void *newArray_mu2ecLcLCaloShowerSim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerSim[nElements] : new ::mu2e::CaloShowerSim[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloShowerSim(void *p) {
      delete ((::mu2e::CaloShowerSim*)p);
   }
   static void deleteArray_mu2ecLcLCaloShowerSim(void *p) {
      delete [] ((::mu2e::CaloShowerSim*)p);
   }
   static void destruct_mu2ecLcLCaloShowerSim(void *p) {
      typedef ::mu2e::CaloShowerSim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloShowerSim

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloShowerStepRO(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerStepRO : new ::mu2e::CaloShowerStepRO;
   }
   static void *newArray_mu2ecLcLCaloShowerStepRO(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloShowerStepRO[nElements] : new ::mu2e::CaloShowerStepRO[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloShowerStepRO(void *p) {
      delete ((::mu2e::CaloShowerStepRO*)p);
   }
   static void deleteArray_mu2ecLcLCaloShowerStepRO(void *p) {
      delete [] ((::mu2e::CaloShowerStepRO*)p);
   }
   static void destruct_mu2ecLcLCaloShowerStepRO(void *p) {
      typedef ::mu2e::CaloShowerStepRO current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloShowerStepRO

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloHitMCTruth(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloHitMCTruth : new ::mu2e::CaloHitMCTruth;
   }
   static void *newArray_mu2ecLcLCaloHitMCTruth(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloHitMCTruth[nElements] : new ::mu2e::CaloHitMCTruth[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloHitMCTruth(void *p) {
      delete ((::mu2e::CaloHitMCTruth*)p);
   }
   static void deleteArray_mu2ecLcLCaloHitMCTruth(void *p) {
      delete [] ((::mu2e::CaloHitMCTruth*)p);
   }
   static void destruct_mu2ecLcLCaloHitMCTruth(void *p) {
      typedef ::mu2e::CaloHitMCTruth current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloHitMCTruth

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloDigiMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloDigiMC : new ::mu2e::CaloDigiMC;
   }
   static void *newArray_mu2ecLcLCaloDigiMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloDigiMC[nElements] : new ::mu2e::CaloDigiMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloDigiMC(void *p) {
      delete ((::mu2e::CaloDigiMC*)p);
   }
   static void deleteArray_mu2ecLcLCaloDigiMC(void *p) {
      delete [] ((::mu2e::CaloDigiMC*)p);
   }
   static void destruct_mu2ecLcLCaloDigiMC(void *p) {
      typedef ::mu2e::CaloDigiMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloDigiMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLStepPointMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StepPointMC : new ::mu2e::StepPointMC;
   }
   static void *newArray_mu2ecLcLStepPointMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StepPointMC[nElements] : new ::mu2e::StepPointMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLStepPointMC(void *p) {
      delete ((::mu2e::StepPointMC*)p);
   }
   static void deleteArray_mu2ecLcLStepPointMC(void *p) {
      delete [] ((::mu2e::StepPointMC*)p);
   }
   static void destruct_mu2ecLcLStepPointMC(void *p) {
      typedef ::mu2e::StepPointMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::StepPointMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloHitSimPartMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloHitSimPartMC : new ::mu2e::CaloHitSimPartMC;
   }
   static void *newArray_mu2ecLcLCaloHitSimPartMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloHitSimPartMC[nElements] : new ::mu2e::CaloHitSimPartMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloHitSimPartMC(void *p) {
      delete ((::mu2e::CaloHitSimPartMC*)p);
   }
   static void deleteArray_mu2ecLcLCaloHitSimPartMC(void *p) {
      delete [] ((::mu2e::CaloHitSimPartMC*)p);
   }
   static void destruct_mu2ecLcLCaloHitSimPartMC(void *p) {
      typedef ::mu2e::CaloHitSimPartMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloHitSimPartMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCaloClusterContentMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloClusterContentMC : new ::mu2e::CaloClusterContentMC;
   }
   static void *newArray_mu2ecLcLCaloClusterContentMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CaloClusterContentMC[nElements] : new ::mu2e::CaloClusterContentMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCaloClusterContentMC(void *p) {
      delete ((::mu2e::CaloClusterContentMC*)p);
   }
   static void deleteArray_mu2ecLcLCaloClusterContentMC(void *p) {
      delete [] ((::mu2e::CaloClusterContentMC*)p);
   }
   static void destruct_mu2ecLcLCaloClusterContentMC(void *p) {
      typedef ::mu2e::CaloClusterContentMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CaloClusterContentMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvPhotons(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvPhotons : new ::mu2e::CrvPhotons;
   }
   static void *newArray_mu2ecLcLCrvPhotons(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvPhotons[nElements] : new ::mu2e::CrvPhotons[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvPhotons(void *p) {
      delete ((::mu2e::CrvPhotons*)p);
   }
   static void deleteArray_mu2ecLcLCrvPhotons(void *p) {
      delete [] ((::mu2e::CrvPhotons*)p);
   }
   static void destruct_mu2ecLcLCrvPhotons(void *p) {
      typedef ::mu2e::CrvPhotons current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvPhotons

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvPhotons::SinglePhoton : new ::mu2e::CrvPhotons::SinglePhoton;
   }
   static void *newArray_mu2ecLcLCrvPhotonscLcLSinglePhoton(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvPhotons::SinglePhoton[nElements] : new ::mu2e::CrvPhotons::SinglePhoton[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p) {
      delete ((::mu2e::CrvPhotons::SinglePhoton*)p);
   }
   static void deleteArray_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p) {
      delete [] ((::mu2e::CrvPhotons::SinglePhoton*)p);
   }
   static void destruct_mu2ecLcLCrvPhotonscLcLSinglePhoton(void *p) {
      typedef ::mu2e::CrvPhotons::SinglePhoton current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvPhotons::SinglePhoton

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvSiPMCharges(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvSiPMCharges : new ::mu2e::CrvSiPMCharges;
   }
   static void *newArray_mu2ecLcLCrvSiPMCharges(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvSiPMCharges[nElements] : new ::mu2e::CrvSiPMCharges[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvSiPMCharges(void *p) {
      delete ((::mu2e::CrvSiPMCharges*)p);
   }
   static void deleteArray_mu2ecLcLCrvSiPMCharges(void *p) {
      delete [] ((::mu2e::CrvSiPMCharges*)p);
   }
   static void destruct_mu2ecLcLCrvSiPMCharges(void *p) {
      typedef ::mu2e::CrvSiPMCharges current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvSiPMCharges

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvSiPMCharges::CrvSingleCharge : new ::mu2e::CrvSiPMCharges::CrvSingleCharge;
   }
   static void *newArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvSiPMCharges::CrvSingleCharge[nElements] : new ::mu2e::CrvSiPMCharges::CrvSingleCharge[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p) {
      delete ((::mu2e::CrvSiPMCharges::CrvSingleCharge*)p);
   }
   static void deleteArray_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p) {
      delete [] ((::mu2e::CrvSiPMCharges::CrvSingleCharge*)p);
   }
   static void destruct_mu2ecLcLCrvSiPMChargescLcLCrvSingleCharge(void *p) {
      typedef ::mu2e::CrvSiPMCharges::CrvSingleCharge current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvSiPMCharges::CrvSingleCharge

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvDigiMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvDigiMC : new ::mu2e::CrvDigiMC;
   }
   static void *newArray_mu2ecLcLCrvDigiMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvDigiMC[nElements] : new ::mu2e::CrvDigiMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvDigiMC(void *p) {
      delete ((::mu2e::CrvDigiMC*)p);
   }
   static void deleteArray_mu2ecLcLCrvDigiMC(void *p) {
      delete [] ((::mu2e::CrvDigiMC*)p);
   }
   static void destruct_mu2ecLcLCrvDigiMC(void *p) {
      typedef ::mu2e::CrvDigiMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvDigiMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvDigiMC::CrvSingleWaveform : new ::mu2e::CrvDigiMC::CrvSingleWaveform;
   }
   static void *newArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::CrvDigiMC::CrvSingleWaveform[nElements] : new ::mu2e::CrvDigiMC::CrvSingleWaveform[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p) {
      delete ((::mu2e::CrvDigiMC::CrvSingleWaveform*)p);
   }
   static void deleteArray_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p) {
      delete [] ((::mu2e::CrvDigiMC::CrvSingleWaveform*)p);
   }
   static void destruct_mu2ecLcLCrvDigiMCcLcLCrvSingleWaveform(void *p) {
      typedef ::mu2e::CrvDigiMC::CrvSingleWaveform current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::CrvDigiMC::CrvSingleWaveform

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLExtMonUCITofHitMCTruth(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonUCITofHitMCTruth : new ::mu2e::ExtMonUCITofHitMCTruth;
   }
   static void *newArray_mu2ecLcLExtMonUCITofHitMCTruth(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonUCITofHitMCTruth[nElements] : new ::mu2e::ExtMonUCITofHitMCTruth[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLExtMonUCITofHitMCTruth(void *p) {
      delete ((::mu2e::ExtMonUCITofHitMCTruth*)p);
   }
   static void deleteArray_mu2ecLcLExtMonUCITofHitMCTruth(void *p) {
      delete [] ((::mu2e::ExtMonUCITofHitMCTruth*)p);
   }
   static void destruct_mu2ecLcLExtMonUCITofHitMCTruth(void *p) {
      typedef ::mu2e::ExtMonUCITofHitMCTruth current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ExtMonUCITofHitMCTruth

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLG4BeamlineInfo(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::G4BeamlineInfo : new ::mu2e::G4BeamlineInfo;
   }
   static void *newArray_mu2ecLcLG4BeamlineInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::G4BeamlineInfo[nElements] : new ::mu2e::G4BeamlineInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLG4BeamlineInfo(void *p) {
      delete ((::mu2e::G4BeamlineInfo*)p);
   }
   static void deleteArray_mu2ecLcLG4BeamlineInfo(void *p) {
      delete [] ((::mu2e::G4BeamlineInfo*)p);
   }
   static void destruct_mu2ecLcLG4BeamlineInfo(void *p) {
      typedef ::mu2e::G4BeamlineInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::G4BeamlineInfo

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLPhysicalVolumeInfo(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PhysicalVolumeInfo : new ::mu2e::PhysicalVolumeInfo;
   }
   static void *newArray_mu2ecLcLPhysicalVolumeInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PhysicalVolumeInfo[nElements] : new ::mu2e::PhysicalVolumeInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLPhysicalVolumeInfo(void *p) {
      delete ((::mu2e::PhysicalVolumeInfo*)p);
   }
   static void deleteArray_mu2ecLcLPhysicalVolumeInfo(void *p) {
      delete [] ((::mu2e::PhysicalVolumeInfo*)p);
   }
   static void destruct_mu2ecLcLPhysicalVolumeInfo(void *p) {
      typedef ::mu2e::PhysicalVolumeInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::PhysicalVolumeInfo

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLMCTrajectory(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MCTrajectory : new ::mu2e::MCTrajectory;
   }
   static void *newArray_mu2ecLcLMCTrajectory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MCTrajectory[nElements] : new ::mu2e::MCTrajectory[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLMCTrajectory(void *p) {
      delete ((::mu2e::MCTrajectory*)p);
   }
   static void deleteArray_mu2ecLcLMCTrajectory(void *p) {
      delete [] ((::mu2e::MCTrajectory*)p);
   }
   static void destruct_mu2ecLcLMCTrajectory(void *p) {
      typedef ::mu2e::MCTrajectory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::MCTrajectory

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLPointTrajectory(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PointTrajectory : new ::mu2e::PointTrajectory;
   }
   static void *newArray_mu2ecLcLPointTrajectory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::PointTrajectory[nElements] : new ::mu2e::PointTrajectory[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLPointTrajectory(void *p) {
      delete ((::mu2e::PointTrajectory*)p);
   }
   static void deleteArray_mu2ecLcLPointTrajectory(void *p) {
      delete [] ((::mu2e::PointTrajectory*)p);
   }
   static void destruct_mu2ecLcLPointTrajectory(void *p) {
      typedef ::mu2e::PointTrajectory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::PointTrajectory

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLStatusG4(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StatusG4 : new ::mu2e::StatusG4;
   }
   static void *newArray_mu2ecLcLStatusG4(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StatusG4[nElements] : new ::mu2e::StatusG4[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLStatusG4(void *p) {
      delete ((::mu2e::StatusG4*)p);
   }
   static void deleteArray_mu2ecLcLStatusG4(void *p) {
      delete [] ((::mu2e::StatusG4*)p);
   }
   static void destruct_mu2ecLcLStatusG4(void *p) {
      typedef ::mu2e::StatusG4 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::StatusG4

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLStrawHitMCTruth(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StrawHitMCTruth : new ::mu2e::StrawHitMCTruth;
   }
   static void *newArray_mu2ecLcLStrawHitMCTruth(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StrawHitMCTruth[nElements] : new ::mu2e::StrawHitMCTruth[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLStrawHitMCTruth(void *p) {
      delete ((::mu2e::StrawHitMCTruth*)p);
   }
   static void deleteArray_mu2ecLcLStrawHitMCTruth(void *p) {
      delete [] ((::mu2e::StrawHitMCTruth*)p);
   }
   static void destruct_mu2ecLcLStrawHitMCTruth(void *p) {
      typedef ::mu2e::StrawHitMCTruth current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::StrawHitMCTruth

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLStrawDigiMC(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StrawDigiMC : new ::mu2e::StrawDigiMC;
   }
   static void *newArray_mu2ecLcLStrawDigiMC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StrawDigiMC[nElements] : new ::mu2e::StrawDigiMC[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLStrawDigiMC(void *p) {
      delete ((::mu2e::StrawDigiMC*)p);
   }
   static void deleteArray_mu2ecLcLStrawDigiMC(void *p) {
      delete [] ((::mu2e::StrawDigiMC*)p);
   }
   static void destruct_mu2ecLcLStrawDigiMC(void *p) {
      typedef ::mu2e::StrawDigiMC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::StrawDigiMC

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLMixingSummary(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MixingSummary : new ::mu2e::MixingSummary;
   }
   static void *newArray_mu2ecLcLMixingSummary(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MixingSummary[nElements] : new ::mu2e::MixingSummary[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLMixingSummary(void *p) {
      delete ((::mu2e::MixingSummary*)p);
   }
   static void deleteArray_mu2ecLcLMixingSummary(void *p) {
      delete [] ((::mu2e::MixingSummary*)p);
   }
   static void destruct_mu2ecLcLMixingSummary(void *p) {
      typedef ::mu2e::MixingSummary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::MixingSummary

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLGenElHitData(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenElHitData : new ::mu2e::GenElHitData;
   }
   static void *newArray_mu2ecLcLGenElHitData(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenElHitData[nElements] : new ::mu2e::GenElHitData[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLGenElHitData(void *p) {
      delete ((::mu2e::GenElHitData*)p);
   }
   static void deleteArray_mu2ecLcLGenElHitData(void *p) {
      delete [] ((::mu2e::GenElHitData*)p);
   }
   static void destruct_mu2ecLcLGenElHitData(void *p) {
      typedef ::mu2e::GenElHitData current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::GenElHitData

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLVisibleGenElTrack(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::VisibleGenElTrack : new ::mu2e::VisibleGenElTrack;
   }
   static void *newArray_mu2ecLcLVisibleGenElTrack(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::VisibleGenElTrack[nElements] : new ::mu2e::VisibleGenElTrack[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLVisibleGenElTrack(void *p) {
      delete ((::mu2e::VisibleGenElTrack*)p);
   }
   static void deleteArray_mu2ecLcLVisibleGenElTrack(void *p) {
      delete [] ((::mu2e::VisibleGenElTrack*)p);
   }
   static void destruct_mu2ecLcLVisibleGenElTrack(void *p) {
      typedef ::mu2e::VisibleGenElTrack current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::VisibleGenElTrack

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLExtMonFNALSimHit(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALSimHit : new ::mu2e::ExtMonFNALSimHit;
   }
   static void *newArray_mu2ecLcLExtMonFNALSimHit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALSimHit[nElements] : new ::mu2e::ExtMonFNALSimHit[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLExtMonFNALSimHit(void *p) {
      delete ((::mu2e::ExtMonFNALSimHit*)p);
   }
   static void deleteArray_mu2ecLcLExtMonFNALSimHit(void *p) {
      delete [] ((::mu2e::ExtMonFNALSimHit*)p);
   }
   static void destruct_mu2ecLcLExtMonFNALSimHit(void *p) {
      typedef ::mu2e::ExtMonFNALSimHit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ExtMonFNALSimHit

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLExtMonFNALHitTruthBits(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALHitTruthBits : new ::mu2e::ExtMonFNALHitTruthBits;
   }
   static void *newArray_mu2ecLcLExtMonFNALHitTruthBits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALHitTruthBits[nElements] : new ::mu2e::ExtMonFNALHitTruthBits[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLExtMonFNALHitTruthBits(void *p) {
      delete ((::mu2e::ExtMonFNALHitTruthBits*)p);
   }
   static void deleteArray_mu2ecLcLExtMonFNALHitTruthBits(void *p) {
      delete [] ((::mu2e::ExtMonFNALHitTruthBits*)p);
   }
   static void destruct_mu2ecLcLExtMonFNALHitTruthBits(void *p) {
      typedef ::mu2e::ExtMonFNALHitTruthBits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ExtMonFNALHitTruthBits

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALRecoClusterTruthBits : new ::mu2e::ExtMonFNALRecoClusterTruthBits;
   }
   static void *newArray_mu2ecLcLExtMonFNALRecoClusterTruthBits(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALRecoClusterTruthBits[nElements] : new ::mu2e::ExtMonFNALRecoClusterTruthBits[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p) {
      delete ((::mu2e::ExtMonFNALRecoClusterTruthBits*)p);
   }
   static void deleteArray_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p) {
      delete [] ((::mu2e::ExtMonFNALRecoClusterTruthBits*)p);
   }
   static void destruct_mu2ecLcLExtMonFNALRecoClusterTruthBits(void *p) {
      typedef ::mu2e::ExtMonFNALRecoClusterTruthBits current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ExtMonFNALRecoClusterTruthBits

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLExtMonFNALTrkMatchInfo(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALTrkMatchInfo : new ::mu2e::ExtMonFNALTrkMatchInfo;
   }
   static void *newArray_mu2ecLcLExtMonFNALTrkMatchInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ExtMonFNALTrkMatchInfo[nElements] : new ::mu2e::ExtMonFNALTrkMatchInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLExtMonFNALTrkMatchInfo(void *p) {
      delete ((::mu2e::ExtMonFNALTrkMatchInfo*)p);
   }
   static void deleteArray_mu2ecLcLExtMonFNALTrkMatchInfo(void *p) {
      delete [] ((::mu2e::ExtMonFNALTrkMatchInfo*)p);
   }
   static void destruct_mu2ecLcLExtMonFNALTrkMatchInfo(void *p) {
      typedef ::mu2e::ExtMonFNALTrkMatchInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ExtMonFNALTrkMatchInfo

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLMARSInfo(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MARSInfo : new ::mu2e::MARSInfo;
   }
   static void *newArray_mu2ecLcLMARSInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::MARSInfo[nElements] : new ::mu2e::MARSInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLMARSInfo(void *p) {
      delete ((::mu2e::MARSInfo*)p);
   }
   static void deleteArray_mu2ecLcLMARSInfo(void *p) {
      delete [] ((::mu2e::MARSInfo*)p);
   }
   static void destruct_mu2ecLcLMARSInfo(void *p) {
      typedef ::mu2e::MARSInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::MARSInfo

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLStepFilterMode(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StepFilterMode : new ::mu2e::StepFilterMode;
   }
   static void *newArray_mu2ecLcLStepFilterMode(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::StepFilterMode[nElements] : new ::mu2e::StepFilterMode[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLStepFilterMode(void *p) {
      delete ((::mu2e::StepFilterMode*)p);
   }
   static void deleteArray_mu2ecLcLStepFilterMode(void *p) {
      delete [] ((::mu2e::StepFilterMode*)p);
   }
   static void destruct_mu2ecLcLStepFilterMode(void *p) {
      typedef ::mu2e::StepFilterMode current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::StepFilterMode

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLGenEventCount(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenEventCount : new ::mu2e::GenEventCount;
   }
   static void *newArray_mu2ecLcLGenEventCount(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::GenEventCount[nElements] : new ::mu2e::GenEventCount[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLGenEventCount(void *p) {
      delete ((::mu2e::GenEventCount*)p);
   }
   static void deleteArray_mu2ecLcLGenEventCount(void *p) {
      delete [] ((::mu2e::GenEventCount*)p);
   }
   static void destruct_mu2ecLcLGenEventCount(void *p) {
      typedef ::mu2e::GenEventCount current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::GenEventCount

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLEventWeight(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::EventWeight : new ::mu2e::EventWeight;
   }
   static void *newArray_mu2ecLcLEventWeight(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::EventWeight[nElements] : new ::mu2e::EventWeight[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLEventWeight(void *p) {
      delete ((::mu2e::EventWeight*)p);
   }
   static void deleteArray_mu2ecLcLEventWeight(void *p) {
      delete [] ((::mu2e::EventWeight*)p);
   }
   static void destruct_mu2ecLcLEventWeight(void *p) {
      typedef ::mu2e::EventWeight current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::EventWeight

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLTrackSummaryMatchInfo(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::TrackSummaryMatchInfo : new ::mu2e::TrackSummaryMatchInfo;
   }
   static void *newArray_mu2ecLcLTrackSummaryMatchInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::TrackSummaryMatchInfo[nElements] : new ::mu2e::TrackSummaryMatchInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLTrackSummaryMatchInfo(void *p) {
      delete ((::mu2e::TrackSummaryMatchInfo*)p);
   }
   static void deleteArray_mu2ecLcLTrackSummaryMatchInfo(void *p) {
      delete [] ((::mu2e::TrackSummaryMatchInfo*)p);
   }
   static void destruct_mu2ecLcLTrackSummaryMatchInfo(void *p) {
      typedef ::mu2e::TrackSummaryMatchInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::TrackSummaryMatchInfo

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLSimParticleTrackerHitSummary(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::SimParticleTrackerHitSummary : new ::mu2e::SimParticleTrackerHitSummary;
   }
   static void *newArray_mu2ecLcLSimParticleTrackerHitSummary(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::SimParticleTrackerHitSummary[nElements] : new ::mu2e::SimParticleTrackerHitSummary[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLSimParticleTrackerHitSummary(void *p) {
      delete ((::mu2e::SimParticleTrackerHitSummary*)p);
   }
   static void deleteArray_mu2ecLcLSimParticleTrackerHitSummary(void *p) {
      delete [] ((::mu2e::SimParticleTrackerHitSummary*)p);
   }
   static void destruct_mu2ecLcLSimParticleTrackerHitSummary(void *p) {
      typedef ::mu2e::SimParticleTrackerHitSummary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::SimParticleTrackerHitSummary

namespace ROOT {
   // Wrappers around operator new
   static void *new_mu2ecLcLProtonBunchIntensity(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ProtonBunchIntensity : new ::mu2e::ProtonBunchIntensity;
   }
   static void *newArray_mu2ecLcLProtonBunchIntensity(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) ::mu2e::ProtonBunchIntensity[nElements] : new ::mu2e::ProtonBunchIntensity[nElements];
   }
   // Wrapper around operator delete
   static void delete_mu2ecLcLProtonBunchIntensity(void *p) {
      delete ((::mu2e::ProtonBunchIntensity*)p);
   }
   static void deleteArray_mu2ecLcLProtonBunchIntensity(void *p) {
      delete [] ((::mu2e::ProtonBunchIntensity*)p);
   }
   static void destruct_mu2ecLcLProtonBunchIntensity(void *p) {
      typedef ::mu2e::ProtonBunchIntensity current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mu2e::ProtonBunchIntensity

namespace ROOT {
   static TClass *vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary();
   static void vectorlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass*);
   static void *new_vectorlEvectorlEunsignedsPlonggRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEunsignedsPlonggRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void destruct_vectorlEvectorlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<unsigned long> >*)
   {
      vector<vector<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<unsigned long> >", -2, "vector", 214,
                  typeid(vector<vector<unsigned long> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<unsigned long> >) );
      instance.SetNew(&new_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEunsignedsPlonggRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<unsigned long> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEvectorlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<vector<unsigned long> >*)0x0)->GetClass();
      vectorlEvectorlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<vector<unsigned long> > : new vector<vector<unsigned long> >;
   }
   static void *newArray_vectorlEvectorlEunsignedsPlonggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<vector<unsigned long> >[nElements] : new vector<vector<unsigned long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete ((vector<vector<unsigned long> >*)p);
   }
   static void deleteArray_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((vector<vector<unsigned long> >*)p);
   }
   static void destruct_vectorlEvectorlEunsignedsPlonggRsPgR(void *p) {
      typedef vector<vector<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<unsigned long> >

namespace ROOT {
   static TClass *vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_Dictionary();
   static void vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<art::Ptr<mu2e::StepPointMC> > >*)
   {
      vector<vector<art::Ptr<mu2e::StepPointMC> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<art::Ptr<mu2e::StepPointMC> > >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<art::Ptr<mu2e::StepPointMC> > >", -2, "vector", 214,
                  typeid(vector<vector<art::Ptr<mu2e::StepPointMC> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<art::Ptr<mu2e::StepPointMC> > >) );
      instance.SetNew(&new_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<art::Ptr<mu2e::StepPointMC> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<art::Ptr<mu2e::StepPointMC> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<vector<art::Ptr<mu2e::StepPointMC> > >*)0x0)->GetClass();
      vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<vector<art::Ptr<mu2e::StepPointMC> > > : new vector<vector<art::Ptr<mu2e::StepPointMC> > >;
   }
   static void *newArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<vector<art::Ptr<mu2e::StepPointMC> > >[nElements] : new vector<vector<art::Ptr<mu2e::StepPointMC> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p) {
      delete ((vector<vector<art::Ptr<mu2e::StepPointMC> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<art::Ptr<mu2e::StepPointMC> > >*)p);
   }
   static void destruct_vectorlEvectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgRsPgR(void *p) {
      typedef vector<vector<art::Ptr<mu2e::StepPointMC> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<art::Ptr<mu2e::StepPointMC> > >

namespace ROOT {
   static TClass *vectorlEunsignedsPlonggR_Dictionary();
   static void vectorlEunsignedsPlonggR_TClassManip(TClass*);
   static void *new_vectorlEunsignedsPlonggR(void *p = 0);
   static void *newArray_vectorlEunsignedsPlonggR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPlonggR(void *p);
   static void deleteArray_vectorlEunsignedsPlonggR(void *p);
   static void destruct_vectorlEunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned long>*)
   {
      vector<unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned long>", -2, "vector", 214,
                  typeid(vector<unsigned long>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEunsignedsPlonggR_Dictionary, isa_proxy, 4,
                  sizeof(vector<unsigned long>) );
      instance.SetNew(&new_vectorlEunsignedsPlonggR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPlonggR);
      instance.SetDelete(&delete_vectorlEunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPlonggR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPlonggR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned long> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<unsigned long>*)0x0)->GetClass();
      vectorlEunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned long> : new vector<unsigned long>;
   }
   static void *newArray_vectorlEunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<unsigned long>[nElements] : new vector<unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPlonggR(void *p) {
      delete ((vector<unsigned long>*)p);
   }
   static void deleteArray_vectorlEunsignedsPlonggR(void *p) {
      delete [] ((vector<unsigned long>*)p);
   }
   static void destruct_vectorlEunsignedsPlonggR(void *p) {
      typedef vector<unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned long>

namespace ROOT {
   static TClass *vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_Dictionary();
   static void vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p);
   static void deleteArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p);
   static void destruct_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >*)
   {
      vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >", -2, "vector", 214,
                  typeid(vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >) );
      instance.SetNew(&new_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >*)0x0)->GetClass();
      vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > : new vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >;
   }
   static void *newArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >[nElements] : new vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p) {
      delete ((vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >*)p);
   }
   static void deleteArray_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p) {
      delete [] ((vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >*)p);
   }
   static void destruct_vectorlEpairlEunsignedsPintcOcetcLcLmap_vectorlEmu2ecLcLPhysicalVolumeInfogRsPgRsPgR(void *p) {
      typedef vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > >

namespace ROOT {
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<cet::map_vector_key,mu2e::SimParticle> >*)
   {
      vector<pair<cet::map_vector_key,mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<cet::map_vector_key,mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<cet::map_vector_key,mu2e::SimParticle> >", -2, "vector", 214,
                  typeid(vector<pair<cet::map_vector_key,mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<cet::map_vector_key,mu2e::SimParticle> >) );
      instance.SetNew(&new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<cet::map_vector_key,mu2e::SimParticle> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::SimParticle> >*)0x0)->GetClass();
      vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::SimParticle> > : new vector<pair<cet::map_vector_key,mu2e::SimParticle> >;
   }
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::SimParticle> >[nElements] : new vector<pair<cet::map_vector_key,mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((vector<pair<cet::map_vector_key,mu2e::SimParticle> >*)p);
   }
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((vector<pair<cet::map_vector_key,mu2e::SimParticle> >*)p);
   }
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef vector<pair<cet::map_vector_key,mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<cet::map_vector_key,mu2e::SimParticle> >

namespace ROOT {
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_Dictionary();
   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p);
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p);
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >*)
   {
      vector<pair<cet::map_vector_key,mu2e::PointTrajectory> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >", -2, "vector", 214,
                  typeid(vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >) );
      instance.SetNew(&new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<cet::map_vector_key,mu2e::PointTrajectory> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >*)0x0)->GetClass();
      vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::PointTrajectory> > : new vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >;
   }
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >[nElements] : new vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p) {
      delete ((vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >*)p);
   }
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p) {
      delete [] ((vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >*)p);
   }
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPointTrajectorygRsPgR(void *p) {
      typedef vector<pair<cet::map_vector_key,mu2e::PointTrajectory> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<cet::map_vector_key,mu2e::PointTrajectory> >

namespace ROOT {
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary();
   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass*);
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p = 0);
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t size, void *p);
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >*)
   {
      vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >", -2, "vector", 214,
                  typeid(vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >) );
      instance.SetNew(&new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetNewArray(&newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDelete(&delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.SetDestructor(&destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >*)0x0)->GetClass();
      vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> > : new vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >;
   }
   static void *newArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >[nElements] : new vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete ((vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void deleteArray_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      delete [] ((vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >*)p);
   }
   static void destruct_vectorlEpairlEcetcLcLmap_vector_keycOmu2ecLcLPhysicalVolumeInfogRsPgR(void *p) {
      typedef vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pair<cet::map_vector_key,mu2e::PhysicalVolumeInfo> >

namespace ROOT {
   static TClass *vectorlEmu2ecLcLVisibleGenElTrackgR_Dictionary();
   static void vectorlEmu2ecLcLVisibleGenElTrackgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLVisibleGenElTrackgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p);
   static void destruct_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::VisibleGenElTrack>*)
   {
      vector<mu2e::VisibleGenElTrack> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::VisibleGenElTrack>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::VisibleGenElTrack>", -2, "vector", 214,
                  typeid(vector<mu2e::VisibleGenElTrack>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLVisibleGenElTrackgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::VisibleGenElTrack>) );
      instance.SetNew(&new_vectorlEmu2ecLcLVisibleGenElTrackgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLVisibleGenElTrackgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLVisibleGenElTrackgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLVisibleGenElTrackgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLVisibleGenElTrackgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::VisibleGenElTrack> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::VisibleGenElTrack>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLVisibleGenElTrackgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::VisibleGenElTrack>*)0x0)->GetClass();
      vectorlEmu2ecLcLVisibleGenElTrackgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLVisibleGenElTrackgR_TClassManip(TClass* theClass){
      theClass->CreateAttributeMap();
      TDictAttributeMap* attrMap( theClass->GetAttributeMap() );
      attrMap->AddProperty("persistent","false");
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::VisibleGenElTrack> : new vector<mu2e::VisibleGenElTrack>;
   }
   static void *newArray_vectorlEmu2ecLcLVisibleGenElTrackgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::VisibleGenElTrack>[nElements] : new vector<mu2e::VisibleGenElTrack>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p) {
      delete ((vector<mu2e::VisibleGenElTrack>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p) {
      delete [] ((vector<mu2e::VisibleGenElTrack>*)p);
   }
   static void destruct_vectorlEmu2ecLcLVisibleGenElTrackgR(void *p) {
      typedef vector<mu2e::VisibleGenElTrack> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::VisibleGenElTrack>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLTrackSummaryMatchInfogR_Dictionary();
   static void vectorlEmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void deleteArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p);
   static void destruct_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::TrackSummaryMatchInfo>*)
   {
      vector<mu2e::TrackSummaryMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::TrackSummaryMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::TrackSummaryMatchInfo>", -2, "vector", 214,
                  typeid(vector<mu2e::TrackSummaryMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLTrackSummaryMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::TrackSummaryMatchInfo>) );
      instance.SetNew(&new_vectorlEmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLTrackSummaryMatchInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::TrackSummaryMatchInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::TrackSummaryMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLTrackSummaryMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::TrackSummaryMatchInfo>*)0x0)->GetClass();
      vectorlEmu2ecLcLTrackSummaryMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLTrackSummaryMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::TrackSummaryMatchInfo> : new vector<mu2e::TrackSummaryMatchInfo>;
   }
   static void *newArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::TrackSummaryMatchInfo>[nElements] : new vector<mu2e::TrackSummaryMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete ((vector<mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      delete [] ((vector<mu2e::TrackSummaryMatchInfo>*)p);
   }
   static void destruct_vectorlEmu2ecLcLTrackSummaryMatchInfogR(void *p) {
      typedef vector<mu2e::TrackSummaryMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::TrackSummaryMatchInfo>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLStrawHitMCTruthgR_Dictionary();
   static void vectorlEmu2ecLcLStrawHitMCTruthgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLStrawHitMCTruthgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p);
   static void destruct_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::StrawHitMCTruth>*)
   {
      vector<mu2e::StrawHitMCTruth> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::StrawHitMCTruth>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::StrawHitMCTruth>", -2, "vector", 214,
                  typeid(vector<mu2e::StrawHitMCTruth>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLStrawHitMCTruthgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::StrawHitMCTruth>) );
      instance.SetNew(&new_vectorlEmu2ecLcLStrawHitMCTruthgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLStrawHitMCTruthgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLStrawHitMCTruthgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLStrawHitMCTruthgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLStrawHitMCTruthgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::StrawHitMCTruth> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::StrawHitMCTruth>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLStrawHitMCTruthgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::StrawHitMCTruth>*)0x0)->GetClass();
      vectorlEmu2ecLcLStrawHitMCTruthgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLStrawHitMCTruthgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StrawHitMCTruth> : new vector<mu2e::StrawHitMCTruth>;
   }
   static void *newArray_vectorlEmu2ecLcLStrawHitMCTruthgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StrawHitMCTruth>[nElements] : new vector<mu2e::StrawHitMCTruth>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p) {
      delete ((vector<mu2e::StrawHitMCTruth>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p) {
      delete [] ((vector<mu2e::StrawHitMCTruth>*)p);
   }
   static void destruct_vectorlEmu2ecLcLStrawHitMCTruthgR(void *p) {
      typedef vector<mu2e::StrawHitMCTruth> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::StrawHitMCTruth>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLStrawDigiMCgR_Dictionary();
   static void vectorlEmu2ecLcLStrawDigiMCgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLStrawDigiMCgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLStrawDigiMCgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLStrawDigiMCgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLStrawDigiMCgR(void *p);
   static void destruct_vectorlEmu2ecLcLStrawDigiMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::StrawDigiMC>*)
   {
      vector<mu2e::StrawDigiMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::StrawDigiMC>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::StrawDigiMC>", -2, "vector", 214,
                  typeid(vector<mu2e::StrawDigiMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLStrawDigiMCgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::StrawDigiMC>) );
      instance.SetNew(&new_vectorlEmu2ecLcLStrawDigiMCgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLStrawDigiMCgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLStrawDigiMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLStrawDigiMCgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLStrawDigiMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::StrawDigiMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::StrawDigiMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLStrawDigiMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::StrawDigiMC>*)0x0)->GetClass();
      vectorlEmu2ecLcLStrawDigiMCgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLStrawDigiMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLStrawDigiMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StrawDigiMC> : new vector<mu2e::StrawDigiMC>;
   }
   static void *newArray_vectorlEmu2ecLcLStrawDigiMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StrawDigiMC>[nElements] : new vector<mu2e::StrawDigiMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLStrawDigiMCgR(void *p) {
      delete ((vector<mu2e::StrawDigiMC>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLStrawDigiMCgR(void *p) {
      delete [] ((vector<mu2e::StrawDigiMC>*)p);
   }
   static void destruct_vectorlEmu2ecLcLStrawDigiMCgR(void *p) {
      typedef vector<mu2e::StrawDigiMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::StrawDigiMC>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLStepPointMCgR_Dictionary();
   static void vectorlEmu2ecLcLStepPointMCgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLStepPointMCgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLStepPointMCgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLStepPointMCgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLStepPointMCgR(void *p);
   static void destruct_vectorlEmu2ecLcLStepPointMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::StepPointMC>*)
   {
      vector<mu2e::StepPointMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::StepPointMC>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::StepPointMC>", -2, "vector", 214,
                  typeid(vector<mu2e::StepPointMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLStepPointMCgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::StepPointMC>) );
      instance.SetNew(&new_vectorlEmu2ecLcLStepPointMCgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLStepPointMCgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLStepPointMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLStepPointMCgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLStepPointMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::StepPointMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::StepPointMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLStepPointMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::StepPointMC>*)0x0)->GetClass();
      vectorlEmu2ecLcLStepPointMCgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLStepPointMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLStepPointMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StepPointMC> : new vector<mu2e::StepPointMC>;
   }
   static void *newArray_vectorlEmu2ecLcLStepPointMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StepPointMC>[nElements] : new vector<mu2e::StepPointMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLStepPointMCgR(void *p) {
      delete ((vector<mu2e::StepPointMC>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLStepPointMCgR(void *p) {
      delete [] ((vector<mu2e::StepPointMC>*)p);
   }
   static void destruct_vectorlEmu2ecLcLStepPointMCgR(void *p) {
      typedef vector<mu2e::StepPointMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::StepPointMC>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLStatusG4gR_Dictionary();
   static void vectorlEmu2ecLcLStatusG4gR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLStatusG4gR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLStatusG4gR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLStatusG4gR(void *p);
   static void deleteArray_vectorlEmu2ecLcLStatusG4gR(void *p);
   static void destruct_vectorlEmu2ecLcLStatusG4gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::StatusG4>*)
   {
      vector<mu2e::StatusG4> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::StatusG4>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::StatusG4>", -2, "vector", 214,
                  typeid(vector<mu2e::StatusG4>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLStatusG4gR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::StatusG4>) );
      instance.SetNew(&new_vectorlEmu2ecLcLStatusG4gR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLStatusG4gR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLStatusG4gR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLStatusG4gR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLStatusG4gR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::StatusG4> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::StatusG4>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLStatusG4gR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::StatusG4>*)0x0)->GetClass();
      vectorlEmu2ecLcLStatusG4gR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLStatusG4gR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLStatusG4gR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StatusG4> : new vector<mu2e::StatusG4>;
   }
   static void *newArray_vectorlEmu2ecLcLStatusG4gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::StatusG4>[nElements] : new vector<mu2e::StatusG4>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLStatusG4gR(void *p) {
      delete ((vector<mu2e::StatusG4>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLStatusG4gR(void *p) {
      delete [] ((vector<mu2e::StatusG4>*)p);
   }
   static void destruct_vectorlEmu2ecLcLStatusG4gR(void *p) {
      typedef vector<mu2e::StatusG4> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::StatusG4>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_Dictionary();
   static void vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p);
   static void deleteArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p);
   static void destruct_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::SimParticleTrackerHitSummary>*)
   {
      vector<mu2e::SimParticleTrackerHitSummary> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::SimParticleTrackerHitSummary>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::SimParticleTrackerHitSummary>", -2, "vector", 214,
                  typeid(vector<mu2e::SimParticleTrackerHitSummary>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::SimParticleTrackerHitSummary>) );
      instance.SetNew(&new_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::SimParticleTrackerHitSummary> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::SimParticleTrackerHitSummary>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::SimParticleTrackerHitSummary>*)0x0)->GetClass();
      vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLSimParticleTrackerHitSummarygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::SimParticleTrackerHitSummary> : new vector<mu2e::SimParticleTrackerHitSummary>;
   }
   static void *newArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::SimParticleTrackerHitSummary>[nElements] : new vector<mu2e::SimParticleTrackerHitSummary>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p) {
      delete ((vector<mu2e::SimParticleTrackerHitSummary>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p) {
      delete [] ((vector<mu2e::SimParticleTrackerHitSummary>*)p);
   }
   static void destruct_vectorlEmu2ecLcLSimParticleTrackerHitSummarygR(void *p) {
      typedef vector<mu2e::SimParticleTrackerHitSummary> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::SimParticleTrackerHitSummary>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary();
   static void vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLPhysicalVolumeInfogR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void deleteArray_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);
   static void destruct_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::PhysicalVolumeInfo>*)
   {
      vector<mu2e::PhysicalVolumeInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::PhysicalVolumeInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::PhysicalVolumeInfo>", -2, "vector", 214,
                  typeid(vector<mu2e::PhysicalVolumeInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::PhysicalVolumeInfo>) );
      instance.SetNew(&new_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLPhysicalVolumeInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::PhysicalVolumeInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::PhysicalVolumeInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLPhysicalVolumeInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::PhysicalVolumeInfo>*)0x0)->GetClass();
      vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLPhysicalVolumeInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::PhysicalVolumeInfo> : new vector<mu2e::PhysicalVolumeInfo>;
   }
   static void *newArray_vectorlEmu2ecLcLPhysicalVolumeInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::PhysicalVolumeInfo>[nElements] : new vector<mu2e::PhysicalVolumeInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete ((vector<mu2e::PhysicalVolumeInfo>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      delete [] ((vector<mu2e::PhysicalVolumeInfo>*)p);
   }
   static void destruct_vectorlEmu2ecLcLPhysicalVolumeInfogR(void *p) {
      typedef vector<mu2e::PhysicalVolumeInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::PhysicalVolumeInfo>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLMARSInfogR_Dictionary();
   static void vectorlEmu2ecLcLMARSInfogR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLMARSInfogR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLMARSInfogR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLMARSInfogR(void *p);
   static void deleteArray_vectorlEmu2ecLcLMARSInfogR(void *p);
   static void destruct_vectorlEmu2ecLcLMARSInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::MARSInfo>*)
   {
      vector<mu2e::MARSInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::MARSInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::MARSInfo>", -2, "vector", 214,
                  typeid(vector<mu2e::MARSInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLMARSInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::MARSInfo>) );
      instance.SetNew(&new_vectorlEmu2ecLcLMARSInfogR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLMARSInfogR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLMARSInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLMARSInfogR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLMARSInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::MARSInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::MARSInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLMARSInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::MARSInfo>*)0x0)->GetClass();
      vectorlEmu2ecLcLMARSInfogR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLMARSInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLMARSInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::MARSInfo> : new vector<mu2e::MARSInfo>;
   }
   static void *newArray_vectorlEmu2ecLcLMARSInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::MARSInfo>[nElements] : new vector<mu2e::MARSInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLMARSInfogR(void *p) {
      delete ((vector<mu2e::MARSInfo>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLMARSInfogR(void *p) {
      delete [] ((vector<mu2e::MARSInfo>*)p);
   }
   static void destruct_vectorlEmu2ecLcLMARSInfogR(void *p) {
      typedef vector<mu2e::MARSInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::MARSInfo>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLGenParticlegR_Dictionary();
   static void vectorlEmu2ecLcLGenParticlegR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLGenParticlegR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLGenParticlegR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLGenParticlegR(void *p);
   static void deleteArray_vectorlEmu2ecLcLGenParticlegR(void *p);
   static void destruct_vectorlEmu2ecLcLGenParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::GenParticle>*)
   {
      vector<mu2e::GenParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::GenParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::GenParticle>", -2, "vector", 214,
                  typeid(vector<mu2e::GenParticle>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLGenParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::GenParticle>) );
      instance.SetNew(&new_vectorlEmu2ecLcLGenParticlegR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLGenParticlegR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLGenParticlegR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLGenParticlegR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLGenParticlegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::GenParticle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::GenParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLGenParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::GenParticle>*)0x0)->GetClass();
      vectorlEmu2ecLcLGenParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLGenParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLGenParticlegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::GenParticle> : new vector<mu2e::GenParticle>;
   }
   static void *newArray_vectorlEmu2ecLcLGenParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::GenParticle>[nElements] : new vector<mu2e::GenParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLGenParticlegR(void *p) {
      delete ((vector<mu2e::GenParticle>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLGenParticlegR(void *p) {
      delete [] ((vector<mu2e::GenParticle>*)p);
   }
   static void destruct_vectorlEmu2ecLcLGenParticlegR(void *p) {
      typedef vector<mu2e::GenParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::GenParticle>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLG4BeamlineInfogR_Dictionary();
   static void vectorlEmu2ecLcLG4BeamlineInfogR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLG4BeamlineInfogR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLG4BeamlineInfogR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLG4BeamlineInfogR(void *p);
   static void deleteArray_vectorlEmu2ecLcLG4BeamlineInfogR(void *p);
   static void destruct_vectorlEmu2ecLcLG4BeamlineInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::G4BeamlineInfo>*)
   {
      vector<mu2e::G4BeamlineInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::G4BeamlineInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::G4BeamlineInfo>", -2, "vector", 214,
                  typeid(vector<mu2e::G4BeamlineInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLG4BeamlineInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::G4BeamlineInfo>) );
      instance.SetNew(&new_vectorlEmu2ecLcLG4BeamlineInfogR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLG4BeamlineInfogR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLG4BeamlineInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::G4BeamlineInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::G4BeamlineInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLG4BeamlineInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::G4BeamlineInfo>*)0x0)->GetClass();
      vectorlEmu2ecLcLG4BeamlineInfogR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLG4BeamlineInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLG4BeamlineInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::G4BeamlineInfo> : new vector<mu2e::G4BeamlineInfo>;
   }
   static void *newArray_vectorlEmu2ecLcLG4BeamlineInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::G4BeamlineInfo>[nElements] : new vector<mu2e::G4BeamlineInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLG4BeamlineInfogR(void *p) {
      delete ((vector<mu2e::G4BeamlineInfo>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLG4BeamlineInfogR(void *p) {
      delete [] ((vector<mu2e::G4BeamlineInfo>*)p);
   }
   static void destruct_vectorlEmu2ecLcLG4BeamlineInfogR(void *p) {
      typedef vector<mu2e::G4BeamlineInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::G4BeamlineInfo>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_Dictionary();
   static void vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p);
   static void destruct_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::ExtMonUCITofHitMCTruth>*)
   {
      vector<mu2e::ExtMonUCITofHitMCTruth> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::ExtMonUCITofHitMCTruth>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::ExtMonUCITofHitMCTruth>", -2, "vector", 214,
                  typeid(vector<mu2e::ExtMonUCITofHitMCTruth>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::ExtMonUCITofHitMCTruth>) );
      instance.SetNew(&new_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::ExtMonUCITofHitMCTruth> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::ExtMonUCITofHitMCTruth>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::ExtMonUCITofHitMCTruth>*)0x0)->GetClass();
      vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonUCITofHitMCTruth> : new vector<mu2e::ExtMonUCITofHitMCTruth>;
   }
   static void *newArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonUCITofHitMCTruth>[nElements] : new vector<mu2e::ExtMonUCITofHitMCTruth>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p) {
      delete ((vector<mu2e::ExtMonUCITofHitMCTruth>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p) {
      delete [] ((vector<mu2e::ExtMonUCITofHitMCTruth>*)p);
   }
   static void destruct_vectorlEmu2ecLcLExtMonUCITofHitMCTruthgR(void *p) {
      typedef vector<mu2e::ExtMonUCITofHitMCTruth> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::ExtMonUCITofHitMCTruth>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary();
   static void vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);
   static void destruct_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::ExtMonFNALTrkMatchInfo>*)
   {
      vector<mu2e::ExtMonFNALTrkMatchInfo> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::ExtMonFNALTrkMatchInfo>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::ExtMonFNALTrkMatchInfo>", -2, "vector", 214,
                  typeid(vector<mu2e::ExtMonFNALTrkMatchInfo>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::ExtMonFNALTrkMatchInfo>) );
      instance.SetNew(&new_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::ExtMonFNALTrkMatchInfo> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALTrkMatchInfo>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALTrkMatchInfo>*)0x0)->GetClass();
      vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALTrkMatchInfo> : new vector<mu2e::ExtMonFNALTrkMatchInfo>;
   }
   static void *newArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALTrkMatchInfo>[nElements] : new vector<mu2e::ExtMonFNALTrkMatchInfo>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete ((vector<mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      delete [] ((vector<mu2e::ExtMonFNALTrkMatchInfo>*)p);
   }
   static void destruct_vectorlEmu2ecLcLExtMonFNALTrkMatchInfogR(void *p) {
      typedef vector<mu2e::ExtMonFNALTrkMatchInfo> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::ExtMonFNALTrkMatchInfo>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLExtMonFNALSimHitgR_Dictionary();
   static void vectorlEmu2ecLcLExtMonFNALSimHitgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLExtMonFNALSimHitgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p);
   static void destruct_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::ExtMonFNALSimHit>*)
   {
      vector<mu2e::ExtMonFNALSimHit> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::ExtMonFNALSimHit>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::ExtMonFNALSimHit>", -2, "vector", 214,
                  typeid(vector<mu2e::ExtMonFNALSimHit>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLExtMonFNALSimHitgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::ExtMonFNALSimHit>) );
      instance.SetNew(&new_vectorlEmu2ecLcLExtMonFNALSimHitgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLExtMonFNALSimHitgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLExtMonFNALSimHitgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLExtMonFNALSimHitgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLExtMonFNALSimHitgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::ExtMonFNALSimHit> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALSimHit>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLExtMonFNALSimHitgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALSimHit>*)0x0)->GetClass();
      vectorlEmu2ecLcLExtMonFNALSimHitgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLExtMonFNALSimHitgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALSimHit> : new vector<mu2e::ExtMonFNALSimHit>;
   }
   static void *newArray_vectorlEmu2ecLcLExtMonFNALSimHitgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALSimHit>[nElements] : new vector<mu2e::ExtMonFNALSimHit>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p) {
      delete ((vector<mu2e::ExtMonFNALSimHit>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p) {
      delete [] ((vector<mu2e::ExtMonFNALSimHit>*)p);
   }
   static void destruct_vectorlEmu2ecLcLExtMonFNALSimHitgR(void *p) {
      typedef vector<mu2e::ExtMonFNALSimHit> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::ExtMonFNALSimHit>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary();
   static void vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);
   static void destruct_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::ExtMonFNALRecoClusterTruthBits>*)
   {
      vector<mu2e::ExtMonFNALRecoClusterTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::ExtMonFNALRecoClusterTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::ExtMonFNALRecoClusterTruthBits>", -2, "vector", 214,
                  typeid(vector<mu2e::ExtMonFNALRecoClusterTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::ExtMonFNALRecoClusterTruthBits>) );
      instance.SetNew(&new_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::ExtMonFNALRecoClusterTruthBits> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALRecoClusterTruthBits>*)0x0)->GetClass();
      vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALRecoClusterTruthBits> : new vector<mu2e::ExtMonFNALRecoClusterTruthBits>;
   }
   static void *newArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALRecoClusterTruthBits>[nElements] : new vector<mu2e::ExtMonFNALRecoClusterTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete ((vector<mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      delete [] ((vector<mu2e::ExtMonFNALRecoClusterTruthBits>*)p);
   }
   static void destruct_vectorlEmu2ecLcLExtMonFNALRecoClusterTruthBitsgR(void *p) {
      typedef vector<mu2e::ExtMonFNALRecoClusterTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::ExtMonFNALRecoClusterTruthBits>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary();
   static void vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);
   static void destruct_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::ExtMonFNALHitTruthBits>*)
   {
      vector<mu2e::ExtMonFNALHitTruthBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::ExtMonFNALHitTruthBits>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::ExtMonFNALHitTruthBits>", -2, "vector", 214,
                  typeid(vector<mu2e::ExtMonFNALHitTruthBits>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::ExtMonFNALHitTruthBits>) );
      instance.SetNew(&new_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::ExtMonFNALHitTruthBits> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALHitTruthBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::ExtMonFNALHitTruthBits>*)0x0)->GetClass();
      vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALHitTruthBits> : new vector<mu2e::ExtMonFNALHitTruthBits>;
   }
   static void *newArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::ExtMonFNALHitTruthBits>[nElements] : new vector<mu2e::ExtMonFNALHitTruthBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete ((vector<mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      delete [] ((vector<mu2e::ExtMonFNALHitTruthBits>*)p);
   }
   static void destruct_vectorlEmu2ecLcLExtMonFNALHitTruthBitsgR(void *p) {
      typedef vector<mu2e::ExtMonFNALHitTruthBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::ExtMonFNALHitTruthBits>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_Dictionary();
   static void vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p);
   static void destruct_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CrvSiPMCharges::CrvSingleCharge>*)
   {
      vector<mu2e::CrvSiPMCharges::CrvSingleCharge> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CrvSiPMCharges::CrvSingleCharge>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CrvSiPMCharges::CrvSingleCharge>", -2, "vector", 214,
                  typeid(vector<mu2e::CrvSiPMCharges::CrvSingleCharge>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CrvSiPMCharges::CrvSingleCharge>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CrvSiPMCharges::CrvSingleCharge> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CrvSiPMCharges::CrvSingleCharge>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CrvSiPMCharges::CrvSingleCharge>*)0x0)->GetClass();
      vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvSiPMCharges::CrvSingleCharge> : new vector<mu2e::CrvSiPMCharges::CrvSingleCharge>;
   }
   static void *newArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvSiPMCharges::CrvSingleCharge>[nElements] : new vector<mu2e::CrvSiPMCharges::CrvSingleCharge>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p) {
      delete ((vector<mu2e::CrvSiPMCharges::CrvSingleCharge>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p) {
      delete [] ((vector<mu2e::CrvSiPMCharges::CrvSingleCharge>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCrvSiPMChargescLcLCrvSingleChargegR(void *p) {
      typedef vector<mu2e::CrvSiPMCharges::CrvSingleCharge> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CrvSiPMCharges::CrvSingleCharge>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_Dictionary();
   static void vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p);
   static void destruct_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CrvPhotons::SinglePhoton>*)
   {
      vector<mu2e::CrvPhotons::SinglePhoton> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CrvPhotons::SinglePhoton>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CrvPhotons::SinglePhoton>", -2, "vector", 214,
                  typeid(vector<mu2e::CrvPhotons::SinglePhoton>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CrvPhotons::SinglePhoton>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CrvPhotons::SinglePhoton> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CrvPhotons::SinglePhoton>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CrvPhotons::SinglePhoton>*)0x0)->GetClass();
      vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvPhotons::SinglePhoton> : new vector<mu2e::CrvPhotons::SinglePhoton>;
   }
   static void *newArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvPhotons::SinglePhoton>[nElements] : new vector<mu2e::CrvPhotons::SinglePhoton>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p) {
      delete ((vector<mu2e::CrvPhotons::SinglePhoton>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p) {
      delete [] ((vector<mu2e::CrvPhotons::SinglePhoton>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCrvPhotonscLcLSinglePhotongR(void *p) {
      typedef vector<mu2e::CrvPhotons::SinglePhoton> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CrvPhotons::SinglePhoton>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_Dictionary();
   static void vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p);
   static void destruct_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CrvDigiMC::CrvSingleWaveform>*)
   {
      vector<mu2e::CrvDigiMC::CrvSingleWaveform> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CrvDigiMC::CrvSingleWaveform>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CrvDigiMC::CrvSingleWaveform>", -2, "vector", 214,
                  typeid(vector<mu2e::CrvDigiMC::CrvSingleWaveform>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CrvDigiMC::CrvSingleWaveform>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CrvDigiMC::CrvSingleWaveform> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CrvDigiMC::CrvSingleWaveform>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CrvDigiMC::CrvSingleWaveform>*)0x0)->GetClass();
      vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvDigiMC::CrvSingleWaveform> : new vector<mu2e::CrvDigiMC::CrvSingleWaveform>;
   }
   static void *newArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CrvDigiMC::CrvSingleWaveform>[nElements] : new vector<mu2e::CrvDigiMC::CrvSingleWaveform>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p) {
      delete ((vector<mu2e::CrvDigiMC::CrvSingleWaveform>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p) {
      delete [] ((vector<mu2e::CrvDigiMC::CrvSingleWaveform>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCrvDigiMCcLcLCrvSingleWaveformgR(void *p) {
      typedef vector<mu2e::CrvDigiMC::CrvSingleWaveform> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CrvDigiMC::CrvSingleWaveform>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloShowerStepROgR_Dictionary();
   static void vectorlEmu2ecLcLCaloShowerStepROgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloShowerStepROgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloShowerStepROgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloShowerStepROgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloShowerStepROgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloShowerStepROgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloShowerStepRO>*)
   {
      vector<mu2e::CaloShowerStepRO> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloShowerStepRO>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloShowerStepRO>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloShowerStepRO>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloShowerStepROgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloShowerStepRO>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloShowerStepROgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloShowerStepROgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloShowerStepROgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloShowerStepROgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloShowerStepROgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloShowerStepRO> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloShowerStepRO>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloShowerStepROgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloShowerStepRO>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloShowerStepROgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloShowerStepROgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloShowerStepROgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerStepRO> : new vector<mu2e::CaloShowerStepRO>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloShowerStepROgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerStepRO>[nElements] : new vector<mu2e::CaloShowerStepRO>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloShowerStepROgR(void *p) {
      delete ((vector<mu2e::CaloShowerStepRO>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloShowerStepROgR(void *p) {
      delete [] ((vector<mu2e::CaloShowerStepRO>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloShowerStepROgR(void *p) {
      typedef vector<mu2e::CaloShowerStepRO> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloShowerStepRO>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloShowerStepgR_Dictionary();
   static void vectorlEmu2ecLcLCaloShowerStepgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloShowerStepgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloShowerStepgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloShowerStepgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloShowerStepgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloShowerStepgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloShowerStep>*)
   {
      vector<mu2e::CaloShowerStep> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloShowerStep>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloShowerStep>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloShowerStep>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloShowerStepgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloShowerStep>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloShowerStepgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloShowerStepgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloShowerStepgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloShowerStepgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloShowerStepgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloShowerStep> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloShowerStep>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloShowerStepgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloShowerStep>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloShowerStepgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloShowerStepgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloShowerStepgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerStep> : new vector<mu2e::CaloShowerStep>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloShowerStepgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerStep>[nElements] : new vector<mu2e::CaloShowerStep>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloShowerStepgR(void *p) {
      delete ((vector<mu2e::CaloShowerStep>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloShowerStepgR(void *p) {
      delete [] ((vector<mu2e::CaloShowerStep>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloShowerStepgR(void *p) {
      typedef vector<mu2e::CaloShowerStep> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloShowerStep>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloShowerSimgR_Dictionary();
   static void vectorlEmu2ecLcLCaloShowerSimgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloShowerSimgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloShowerSimgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloShowerSimgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloShowerSimgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloShowerSimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloShowerSim>*)
   {
      vector<mu2e::CaloShowerSim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloShowerSim>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloShowerSim>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloShowerSim>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloShowerSimgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloShowerSim>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloShowerSimgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloShowerSimgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloShowerSimgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloShowerSimgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloShowerSimgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloShowerSim> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloShowerSim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloShowerSimgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloShowerSim>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloShowerSimgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloShowerSimgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloShowerSimgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerSim> : new vector<mu2e::CaloShowerSim>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloShowerSimgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloShowerSim>[nElements] : new vector<mu2e::CaloShowerSim>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloShowerSimgR(void *p) {
      delete ((vector<mu2e::CaloShowerSim>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloShowerSimgR(void *p) {
      delete [] ((vector<mu2e::CaloShowerSim>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloShowerSimgR(void *p) {
      typedef vector<mu2e::CaloShowerSim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloShowerSim>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloHitSimPartMCgR_Dictionary();
   static void vectorlEmu2ecLcLCaloHitSimPartMCgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloHitSimPartMCgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloHitSimPartMC>*)
   {
      vector<mu2e::CaloHitSimPartMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloHitSimPartMC>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloHitSimPartMC>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloHitSimPartMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloHitSimPartMCgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloHitSimPartMC>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloHitSimPartMCgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloHitSimPartMCgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloHitSimPartMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloHitSimPartMCgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloHitSimPartMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloHitSimPartMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloHitSimPartMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloHitSimPartMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloHitSimPartMC>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloHitSimPartMCgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloHitSimPartMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloHitSimPartMC> : new vector<mu2e::CaloHitSimPartMC>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloHitSimPartMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloHitSimPartMC>[nElements] : new vector<mu2e::CaloHitSimPartMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p) {
      delete ((vector<mu2e::CaloHitSimPartMC>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p) {
      delete [] ((vector<mu2e::CaloHitSimPartMC>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloHitSimPartMCgR(void *p) {
      typedef vector<mu2e::CaloHitSimPartMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloHitSimPartMC>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloHitMCTruthgR_Dictionary();
   static void vectorlEmu2ecLcLCaloHitMCTruthgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloHitMCTruthgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloHitMCTruth>*)
   {
      vector<mu2e::CaloHitMCTruth> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloHitMCTruth>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloHitMCTruth>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloHitMCTruth>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloHitMCTruthgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloHitMCTruth>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloHitMCTruthgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloHitMCTruthgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloHitMCTruthgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloHitMCTruthgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloHitMCTruthgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloHitMCTruth> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloHitMCTruth>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloHitMCTruthgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloHitMCTruth>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloHitMCTruthgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloHitMCTruthgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloHitMCTruth> : new vector<mu2e::CaloHitMCTruth>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloHitMCTruthgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloHitMCTruth>[nElements] : new vector<mu2e::CaloHitMCTruth>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p) {
      delete ((vector<mu2e::CaloHitMCTruth>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p) {
      delete [] ((vector<mu2e::CaloHitMCTruth>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloHitMCTruthgR(void *p) {
      typedef vector<mu2e::CaloHitMCTruth> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloHitMCTruth>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloDigiMCgR_Dictionary();
   static void vectorlEmu2ecLcLCaloDigiMCgR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloDigiMCgR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloDigiMCgR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloDigiMCgR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloDigiMCgR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloDigiMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloDigiMC>*)
   {
      vector<mu2e::CaloDigiMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloDigiMC>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloDigiMC>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloDigiMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloDigiMCgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloDigiMC>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloDigiMCgR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloDigiMCgR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloDigiMCgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloDigiMCgR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloDigiMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloDigiMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloDigiMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloDigiMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloDigiMC>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloDigiMCgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloDigiMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloDigiMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloDigiMC> : new vector<mu2e::CaloDigiMC>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloDigiMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloDigiMC>[nElements] : new vector<mu2e::CaloDigiMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloDigiMCgR(void *p) {
      delete ((vector<mu2e::CaloDigiMC>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloDigiMCgR(void *p) {
      delete [] ((vector<mu2e::CaloDigiMC>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloDigiMCgR(void *p) {
      typedef vector<mu2e::CaloDigiMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloDigiMC>

namespace ROOT {
   static TClass *vectorlEmu2ecLcLCaloDigigR_Dictionary();
   static void vectorlEmu2ecLcLCaloDigigR_TClassManip(TClass*);
   static void *new_vectorlEmu2ecLcLCaloDigigR(void *p = 0);
   static void *newArray_vectorlEmu2ecLcLCaloDigigR(Long_t size, void *p);
   static void delete_vectorlEmu2ecLcLCaloDigigR(void *p);
   static void deleteArray_vectorlEmu2ecLcLCaloDigigR(void *p);
   static void destruct_vectorlEmu2ecLcLCaloDigigR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mu2e::CaloDigi>*)
   {
      vector<mu2e::CaloDigi> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mu2e::CaloDigi>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<mu2e::CaloDigi>", -2, "vector", 214,
                  typeid(vector<mu2e::CaloDigi>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEmu2ecLcLCaloDigigR_Dictionary, isa_proxy, 4,
                  sizeof(vector<mu2e::CaloDigi>) );
      instance.SetNew(&new_vectorlEmu2ecLcLCaloDigigR);
      instance.SetNewArray(&newArray_vectorlEmu2ecLcLCaloDigigR);
      instance.SetDelete(&delete_vectorlEmu2ecLcLCaloDigigR);
      instance.SetDeleteArray(&deleteArray_vectorlEmu2ecLcLCaloDigigR);
      instance.SetDestructor(&destruct_vectorlEmu2ecLcLCaloDigigR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mu2e::CaloDigi> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mu2e::CaloDigi>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEmu2ecLcLCaloDigigR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<mu2e::CaloDigi>*)0x0)->GetClass();
      vectorlEmu2ecLcLCaloDigigR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEmu2ecLcLCaloDigigR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmu2ecLcLCaloDigigR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloDigi> : new vector<mu2e::CaloDigi>;
   }
   static void *newArray_vectorlEmu2ecLcLCaloDigigR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<mu2e::CaloDigi>[nElements] : new vector<mu2e::CaloDigi>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmu2ecLcLCaloDigigR(void *p) {
      delete ((vector<mu2e::CaloDigi>*)p);
   }
   static void deleteArray_vectorlEmu2ecLcLCaloDigigR(void *p) {
      delete [] ((vector<mu2e::CaloDigi>*)p);
   }
   static void destruct_vectorlEmu2ecLcLCaloDigigR(void *p) {
      typedef vector<mu2e::CaloDigi> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mu2e::CaloDigi>

namespace ROOT {
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_Dictionary();
   static void vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p = 0);
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(Long_t size, void *p);
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p);
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p);
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<art::Ptr<mu2e::StepPointMC> >*)
   {
      vector<art::Ptr<mu2e::StepPointMC> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<art::Ptr<mu2e::StepPointMC> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<art::Ptr<mu2e::StepPointMC> >", -2, "vector", 214,
                  typeid(vector<art::Ptr<mu2e::StepPointMC> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<art::Ptr<mu2e::StepPointMC> >) );
      instance.SetNew(&new_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetNewArray(&newArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDelete(&delete_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR);
      instance.SetDestructor(&destruct_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<art::Ptr<mu2e::StepPointMC> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::StepPointMC> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::StepPointMC> >*)0x0)->GetClass();
      vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::StepPointMC> > : new vector<art::Ptr<mu2e::StepPointMC> >;
   }
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::StepPointMC> >[nElements] : new vector<art::Ptr<mu2e::StepPointMC> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      delete ((vector<art::Ptr<mu2e::StepPointMC> >*)p);
   }
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      delete [] ((vector<art::Ptr<mu2e::StepPointMC> >*)p);
   }
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLStepPointMCgRsPgR(void *p) {
      typedef vector<art::Ptr<mu2e::StepPointMC> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<art::Ptr<mu2e::StepPointMC> >

namespace ROOT {
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<art::Ptr<mu2e::SimParticle> >*)
   {
      vector<art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<art::Ptr<mu2e::SimParticle> >", -2, "vector", 214,
                  typeid(vector<art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<art::Ptr<mu2e::SimParticle> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::SimParticle> > : new vector<art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::SimParticle> >[nElements] : new vector<art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((vector<art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((vector<art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef vector<art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<art::Ptr<mu2e::SimParticle> >

namespace ROOT {
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary();
   static void vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p = 0);
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(Long_t size, void *p);
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p);
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p);
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<art::Ptr<mu2e::CaloShowerStep> >*)
   {
      vector<art::Ptr<mu2e::CaloShowerStep> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<art::Ptr<mu2e::CaloShowerStep> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<art::Ptr<mu2e::CaloShowerStep> >", -2, "vector", 214,
                  typeid(vector<art::Ptr<mu2e::CaloShowerStep> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<art::Ptr<mu2e::CaloShowerStep> >) );
      instance.SetNew(&new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetNewArray(&newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDelete(&delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.SetDestructor(&destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<art::Ptr<mu2e::CaloShowerStep> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloShowerStep> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloShowerStep> >*)0x0)->GetClass();
      vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloShowerStep> > : new vector<art::Ptr<mu2e::CaloShowerStep> >;
   }
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloShowerStep> >[nElements] : new vector<art::Ptr<mu2e::CaloShowerStep> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      delete ((vector<art::Ptr<mu2e::CaloShowerStep> >*)p);
   }
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      delete [] ((vector<art::Ptr<mu2e::CaloShowerStep> >*)p);
   }
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerStepgRsPgR(void *p) {
      typedef vector<art::Ptr<mu2e::CaloShowerStep> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<art::Ptr<mu2e::CaloShowerStep> >

namespace ROOT {
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary();
   static void vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p = 0);
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t size, void *p);
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<art::Ptr<mu2e::CaloShowerSim> >*)
   {
      vector<art::Ptr<mu2e::CaloShowerSim> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<art::Ptr<mu2e::CaloShowerSim> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<art::Ptr<mu2e::CaloShowerSim> >", -2, "vector", 214,
                  typeid(vector<art::Ptr<mu2e::CaloShowerSim> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<art::Ptr<mu2e::CaloShowerSim> >) );
      instance.SetNew(&new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetNewArray(&newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDelete(&delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.SetDestructor(&destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<art::Ptr<mu2e::CaloShowerSim> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloShowerSim> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloShowerSim> >*)0x0)->GetClass();
      vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloShowerSim> > : new vector<art::Ptr<mu2e::CaloShowerSim> >;
   }
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloShowerSim> >[nElements] : new vector<art::Ptr<mu2e::CaloShowerSim> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete ((vector<art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      delete [] ((vector<art::Ptr<mu2e::CaloShowerSim> >*)p);
   }
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloShowerSimgRsPgR(void *p) {
      typedef vector<art::Ptr<mu2e::CaloShowerSim> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<art::Ptr<mu2e::CaloShowerSim> >

namespace ROOT {
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_Dictionary();
   static void vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_TClassManip(TClass*);
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p = 0);
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(Long_t size, void *p);
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p);
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p);
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<art::Ptr<mu2e::CaloDigi> >*)
   {
      vector<art::Ptr<mu2e::CaloDigi> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<art::Ptr<mu2e::CaloDigi> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<art::Ptr<mu2e::CaloDigi> >", -2, "vector", 214,
                  typeid(vector<art::Ptr<mu2e::CaloDigi> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<art::Ptr<mu2e::CaloDigi> >) );
      instance.SetNew(&new_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR);
      instance.SetNewArray(&newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDelete(&delete_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR);
      instance.SetDestructor(&destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<art::Ptr<mu2e::CaloDigi> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloDigi> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<art::Ptr<mu2e::CaloDigi> >*)0x0)->GetClass();
      vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloDigi> > : new vector<art::Ptr<mu2e::CaloDigi> >;
   }
   static void *newArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) vector<art::Ptr<mu2e::CaloDigi> >[nElements] : new vector<art::Ptr<mu2e::CaloDigi> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p) {
      delete ((vector<art::Ptr<mu2e::CaloDigi> >*)p);
   }
   static void deleteArray_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p) {
      delete [] ((vector<art::Ptr<mu2e::CaloDigi> >*)p);
   }
   static void destruct_vectorlEartcLcLPtrlEmu2ecLcLCaloDigigRsPgR(void *p) {
      typedef vector<art::Ptr<mu2e::CaloDigi> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<art::Ptr<mu2e::CaloDigi> >

namespace ROOT {
   static TClass *maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_Dictionary();
   static void maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_TClassManip(TClass*);
   static void *new_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p = 0);
   static void *newArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(Long_t size, void *p);
   static void delete_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p);
   static void deleteArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p);
   static void destruct_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<unsigned long,mu2e::GenElHitData>*)
   {
      map<unsigned long,mu2e::GenElHitData> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<unsigned long,mu2e::GenElHitData>));
      static ::ROOT::TGenericClassInfo 
         instance("map<unsigned long,mu2e::GenElHitData>", -2, "map", 96,
                  typeid(map<unsigned long,mu2e::GenElHitData>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_Dictionary, isa_proxy, 4,
                  sizeof(map<unsigned long,mu2e::GenElHitData>) );
      instance.SetNew(&new_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR);
      instance.SetNewArray(&newArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR);
      instance.SetDelete(&delete_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR);
      instance.SetDeleteArray(&deleteArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR);
      instance.SetDestructor(&destruct_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<unsigned long,mu2e::GenElHitData> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<unsigned long,mu2e::GenElHitData>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<unsigned long,mu2e::GenElHitData>*)0x0)->GetClass();
      maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_TClassManip(theClass);
   return theClass;
   }

   static void maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<unsigned long,mu2e::GenElHitData> : new map<unsigned long,mu2e::GenElHitData>;
   }
   static void *newArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<unsigned long,mu2e::GenElHitData>[nElements] : new map<unsigned long,mu2e::GenElHitData>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p) {
      delete ((map<unsigned long,mu2e::GenElHitData>*)p);
   }
   static void deleteArray_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p) {
      delete [] ((map<unsigned long,mu2e::GenElHitData>*)p);
   }
   static void destruct_maplEunsignedsPlongcOmu2ecLcLGenElHitDatagR(void *p) {
      typedef map<unsigned long,mu2e::GenElHitData> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<unsigned long,mu2e::GenElHitData>

namespace ROOT {
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary();
   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(TClass*);
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p = 0);
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(Long_t size, void *p);
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)
   {
      map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>));
      static ::ROOT::TGenericClassInfo 
         instance("map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>", -2, "map", 96,
                  typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary, isa_proxy, 4,
                  sizeof(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>) );
      instance.SetNew(&new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetNewArray(&newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDelete(&delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDeleteArray(&deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.SetDestructor(&destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)0x0)->GetClass();
      maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>;
   }
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>[nElements] : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      delete ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)p);
   }
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      delete [] ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>*)p);
   }
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvSiPMChargesgR(void *p) {
      typedef map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges>

namespace ROOT {
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary();
   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(TClass*);
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p = 0);
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(Long_t size, void *p);
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)
   {
      map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>));
      static ::ROOT::TGenericClassInfo 
         instance("map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>", -2, "map", 96,
                  typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary, isa_proxy, 4,
                  sizeof(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>) );
      instance.SetNew(&new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetNewArray(&newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDelete(&delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDeleteArray(&deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.SetDestructor(&destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)0x0)->GetClass();
      maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>;
   }
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>[nElements] : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      delete ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)p);
   }
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      delete [] ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>*)p);
   }
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvPhotonsgR(void *p) {
      typedef map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons>

namespace ROOT {
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary();
   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(TClass*);
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p = 0);
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(Long_t size, void *p);
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)
   {
      map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>));
      static ::ROOT::TGenericClassInfo 
         instance("map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>", -2, "map", 96,
                  typeid(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary, isa_proxy, 4,
                  sizeof(map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>) );
      instance.SetNew(&new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetNewArray(&newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDelete(&delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDeleteArray(&deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.SetDestructor(&destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)0x0)->GetClass();
      maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>;
   }
   static void *newArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>[nElements] : new map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      delete ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)p);
   }
   static void deleteArray_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      delete [] ((map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>*)p);
   }
   static void destruct_maplEmu2ecLcLCRSScintillatorBarIndexcOmu2ecLcLCrvDigiMCgR(void *p) {
      typedef map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC>

namespace ROOT {
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary();
   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(TClass*);
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p = 0);
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(Long_t size, void *p);
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)
   {
      map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>));
      static ::ROOT::TGenericClassInfo 
         instance("map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>", -2, "map", 96,
                  typeid(map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary, isa_proxy, 4,
                  sizeof(map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>) );
      instance.SetNew(&new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetNewArray(&newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDelete(&delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDeleteArray(&deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.SetDestructor(&destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)0x0)->GetClass();
      maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(theClass);
   return theClass;
   }

   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> : new map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>;
   }
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>[nElements] : new map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      delete ((map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)p);
   }
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      delete [] ((map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>*)p);
   }
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOmu2ecLcLMCTrajectorygR(void *p) {
      typedef map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory>

namespace ROOT {
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary();
   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(TClass*);
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p = 0);
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(Long_t size, void *p);
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<art::Ptr<mu2e::SimParticle>,double>*)
   {
      map<art::Ptr<mu2e::SimParticle>,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<art::Ptr<mu2e::SimParticle>,double>));
      static ::ROOT::TGenericClassInfo 
         instance("map<art::Ptr<mu2e::SimParticle>,double>", -2, "map", 96,
                  typeid(map<art::Ptr<mu2e::SimParticle>,double>), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(map<art::Ptr<mu2e::SimParticle>,double>) );
      instance.SetNew(&new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetNewArray(&newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDelete(&delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDeleteArray(&deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.SetDestructor(&destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<art::Ptr<mu2e::SimParticle>,double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,double>*)0x0)->GetClass();
      maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,double> : new map<art::Ptr<mu2e::SimParticle>,double>;
   }
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,double>[nElements] : new map<art::Ptr<mu2e::SimParticle>,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      delete ((map<art::Ptr<mu2e::SimParticle>,double>*)p);
   }
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      delete [] ((map<art::Ptr<mu2e::SimParticle>,double>*)p);
   }
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOdoublegR(void *p) {
      typedef map<art::Ptr<mu2e::SimParticle>,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<art::Ptr<mu2e::SimParticle>,double>

namespace ROOT {
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary();
   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass*);
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p = 0);
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t size, void *p);
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >*)
   {
      map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >", -2, "map", 96,
                  typeid(map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >), ::ROOT::Internal::DefineBehavior(ptr, ptr),
                  &maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >) );
      instance.SetNew(&new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetNewArray(&newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDelete(&delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.SetDestructor(&destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >*)0x0)->GetClass();
      maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR_TClassManip(TClass* theClass){
      theClass->CreateAttributeMap();
      TDictAttributeMap* attrMap( theClass->GetAttributeMap() );
      attrMap->AddProperty("persistent","false");
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > : new map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >;
   }
   static void *newArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::Internal::TOperatorNewHelper*)p) map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >[nElements] : new map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete ((map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void deleteArray_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      delete [] ((map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >*)p);
   }
   static void destruct_maplEartcLcLPtrlEmu2ecLcLSimParticlegRcOartcLcLPtrlEmu2ecLcLSimParticlegRsPgR(void *p) {
      typedef map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> >

namespace {
  void TriggerDictionaryInitialization_libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict_Impl() {
    static const char* headers[] = {
0    };
    static const char* includePaths[] = {
"/pnfs/mu2e/scratch/users/whyaqm/workflow/Final-CRV-FOVa-5mm/outstage/1535666/00/00001",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/art/v2_07_03/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/canvas/v2_00_02/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/BTrk/v1_02_02/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/messagefacility/v2_00_02/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/fhiclcpp/v4_05_01/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/sqlite/v3_16_02_00a/Linux64bit+2.6-2.12/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/cetlib/v3_00_01/slf6.x86_64.e14.prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/cetlib_except/v1_01_02/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/boost/v1_63_0b/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/clhep/v2_3_4_4/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/cppunit/v1_13_2/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/heppdt/v3_04_01f/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/root/v6_08_06g/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/xerces_c/v3_1_4a/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/tbb/v2017_3c/Linux64bit+2.6-2.12-e14-prof/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/mu2e_artdaq_core/v1_02_00/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/artdaq_core/v1_07_08/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/TRACE/v3_08_01/include",
"/cvmfs/mu2e.opensciencegrid.org/artexternals/root/v6_08_06g/Linux64bit+2.6-2.12-e14-prof/include",
"/mu2e/app/users/whyaqm/Offline/",
0
    };
    static const char* fwdDeclCode = R"DICTFWDDCLS(
#line 1 "libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_Autoloading_Map;
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/PhysicalVolumeInfo.hh")))  PhysicalVolumeInfo;}
namespace cet{template <class Value> class __attribute__((annotate("$clingAutoload$cetlib/map_vector.h")))  __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  map_vector;
}
namespace std{template <class T1, class T2> struct __attribute__((annotate("$clingAutoload$boost/container/detail/std_fwd.hpp")))  __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  pair;
}
namespace cet{class __attribute__((annotate("$clingAutoload$cetlib/map_vector.h")))  __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  map_vector_key;}
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/SimParticle.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  SimParticle;}
namespace CLHEP{class __attribute__((annotate("$clingAutoload$CLHEP/Vector/ThreeVector.h")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  Hep3Vector;}
namespace CLHEP{class __attribute__((annotate("$clingAutoload$CLHEP/Vector/LorentzVector.h")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  HepLorentzVector;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$DataProducts/inc/CRSScintillatorBarIndex.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitSimPartMCCollection.hh")))  CRSScintillatorBarIndex;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvDigiMC.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvDigiMCCollection.hh")))  CrvDigiMC;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvSiPMCharges.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvSiPMChargesCollection.hh")))  CrvSiPMCharges;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvPhotons.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CrvPhotonsCollection.hh")))  CrvPhotons;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/SimParticleTrackerHitSummaryCollection.hh")))  SimParticleTrackerHitSummary;}
namespace art{template <typename T> class __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Ptr.h")))  __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  Ptr;
}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/TrackSummary.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/TrackSummaryTruthAssns.hh")))  TrackSummary;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/ExtMonFNALTrkFit.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALPatRecTruthAssns.hh")))  ExtMonFNALTrkFit;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/ExtMonFNALRecoCluster.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALRecoClusterTruthAssn.hh")))  ExtMonFNALRecoCluster;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/ExtMonFNALRawHit.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALHitTruthAssn.hh")))  ExtMonFNALRawHit;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/MARSInfo.hh")))  MARSInfo;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenParticle.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  GenParticle;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/PointTrajectory.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/PointTrajectoryCollection.hh")))  PointTrajectory;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/MCTrajectory.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/MCTrajectoryCollection.hh")))  MCTrajectory;}
namespace std{template <typename _Tp> class __attribute__((annotate("$clingAutoload$bits/allocator.h")))  __attribute__((annotate("$clingAutoload$string")))  allocator;
}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloShowerStep.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  CaloShowerStep;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloShowerStepRO.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloShowerStepROCollection.hh")))  CaloShowerStepRO;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloShowerSim.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  CaloShowerSim;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/CaloDigi.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  CaloDigi;}
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruth.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthCollection.hh")))  CaloHitMCTruth;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloDigiMC.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloDigiMCCollection.hh")))  CaloDigiMC;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitSimPartMC.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitSimPartMCCollection.hh")))  CaloHitSimPartMC;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StepPointMC.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitSimPartMCCollection.hh")))  StepPointMC;}
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonUCITofHitMCTruth.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonUCITofHitMCTruthCollection.hh")))  ExtMonUCITofHitMCTruth;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/G4BeamlineInfo.hh")))  G4BeamlineInfo;}
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StrawHitMCTruth.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StrawHitMCTruthCollection.hh")))  StrawHitMCTruth;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StrawDigiMC.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StrawDigiMCCollection.hh")))  StrawDigiMC;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StatusG4.hh")))  StatusG4;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/VisibleGenElTrack.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/VisibleGenElTrackCollection.hh")))  VisibleGenElTrack;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALSimHit.hh")))  ExtMonFNALSimHit;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/TrackSummaryTruthAssns.hh")))  TrackSummaryMatchInfo;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALPatRecTruthAssns.hh")))  ExtMonFNALTrkMatchInfo;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALRecoClusterTruthAssn.hh")))  ExtMonFNALRecoClusterTruthBits;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALHitTruthAssn.hh")))  ExtMonFNALHitTruthBits;}
namespace std{template <class T = void> struct __attribute__((annotate("$clingAutoload$boost/container/detail/std_fwd.hpp")))  __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  less;
}
namespace mu2e{struct __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenElHitData.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/VisibleGenElTrackCollection.hh")))  GenElHitData;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/CaloCrystalHit.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  CaloCrystalHit;}
namespace art{template <typename L, typename R, typename D = void> class __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Assns.h")))  Assns;
}
namespace mu2e{class __attribute__((annotate("$clingAutoload$RecoDataProducts/inc/CaloCluster.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloClusterMCTruthAssn.hh")))  CaloCluster;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ProtonBunchIntensity.hh")))  ProtonBunchIntensity;}
namespace art{template <typename T> class __attribute__((annotate("$clingAutoload$canvas/Persistency/Common/Wrapper.h")))  Wrapper;
}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/EventWeight.hh")))  EventWeight;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenEventCount.hh")))  GenEventCount;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/MixingSummary.hh")))  MixingSummary;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$DataProducts/inc/PDGCode.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  PDGCode;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenId.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  GenId;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ProcessCode.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitMCTruthAssn.hh")))  ProcessCode;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloClusterContentMC.hh")))  CaloClusterContentMC;}
namespace mu2e{class __attribute__((annotate("$clingAutoload$MCDataProducts/inc/StepFilterMode.hh")))  StepFilterMode;}
namespace mu2e{typedef cet::map_vector<mu2e::SimParticle> SimParticleCollection __attribute__((annotate("$clingAutoload$MCDataProducts/inc/SimParticleCollection.hh")))  __attribute__((annotate("$clingAutoload$MCDataProducts/inc/CaloHitSimPartMCCollection.hh"))) ;}
namespace mu2e{typedef cet::map_vector<PhysicalVolumeInfo> PhysicalVolumeInfoSingleStage __attribute__((annotate("$clingAutoload$MCDataProducts/inc/PhysicalVolumeInfoMultiCollection.hh"))) ;}
namespace mu2e{typedef cet::map_vector<mu2e::PointTrajectory> PointTrajectoryCollection __attribute__((annotate("$clingAutoload$MCDataProducts/inc/PointTrajectoryCollection.hh"))) ;}
namespace mu2e{typedef art::Assns<GenParticle, StepPointMC> GenParticleSPMHistory __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenParticleSPMHistory.hh"))) ;}
namespace mu2e{typedef art::Assns<GenParticle, SimParticle> GenSimParticleLink __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenSimParticleLink.hh"))) ;}
namespace mu2e{typedef art::Assns<SimParticle, ExtMonFNALTrkFit, ExtMonFNALTrkMatchInfo> ExtMonFNALPatRecTruthAssns __attribute__((annotate("$clingAutoload$MCDataProducts/inc/ExtMonFNALPatRecTruthAssns.hh"))) ;}
namespace mu2e{typedef art::Assns<GenParticle, MARSInfo> GenParticleMARSAssns __attribute__((annotate("$clingAutoload$MCDataProducts/inc/GenParticleMARSAssns.hh"))) ;}
namespace mu2e{typedef art::Assns<SimParticle, MARSInfo> SimParticleMARSAssns __attribute__((annotate("$clingAutoload$MCDataProducts/inc/SimParticleMARSAssns.hh"))) ;}
)DICTFWDDCLS";
    static const char* payloadCode = R"DICTPAYLOAD(
#line 1 "libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef NDEBUG
  #define NDEBUG 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
//
// Original author Rob Kutschke
//

//
// For every type that is described in classes_def.xml, the header must
// be included in this file. It is OK if the header comes in as the
// result of including another header.
//
// Starting with ROOT6, the template instantiations should no longer be
// present.
//
#include <vector>
#include <map>

#include "canvas/Persistency/Common/Wrapper.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/Assns.h"
#include "canvas/Persistency/Common/RNGsnapshot.h"
#include "cetlib/map_vector.h"

#include "MCDataProducts/inc/CaloHitMCTruthAssn.hh"
#include "MCDataProducts/inc/CaloClusterMCTruthAssn.hh"
#include "MCDataProducts/inc/CaloShowerStepROCollection.hh"
#include "MCDataProducts/inc/CaloShowerStepCollection.hh"
#include "MCDataProducts/inc/CaloShowerSimCollection.hh"
#include "RecoDataProducts/inc/CaloDigiCollection.hh"
#include "MCDataProducts/inc/CaloHitMCTruthCollection.hh"
#include "MCDataProducts/inc/CaloDigiMCCollection.hh"
#include "MCDataProducts/inc/CaloHitSimPartMCCollection.hh"
#include "MCDataProducts/inc/CaloClusterContentMC.hh"
#include "RecoDataProducts/inc/CaloCluster.hh"
#include "MCDataProducts/inc/CrvPhotonsCollection.hh"
#include "MCDataProducts/inc/CrvSiPMChargesCollection.hh"
#include "MCDataProducts/inc/CrvDigiMCCollection.hh"
#include "MCDataProducts/inc/ExtMonUCITofHitMCTruthCollection.hh"
#include "MCDataProducts/inc/G4BeamlineInfo.hh"
#include "MCDataProducts/inc/G4BeamlineInfoCollection.hh"
#include "MCDataProducts/inc/GenParticleCollection.hh"
#include "MCDataProducts/inc/PhysicalVolumeInfo.hh"
#include "MCDataProducts/inc/PhysicalVolumeInfoCollection.hh"
#include "MCDataProducts/inc/PhysicalVolumeInfoMultiCollection.hh"
#include "MCDataProducts/inc/MCTrajectoryCollection.hh"
#include "MCDataProducts/inc/PointTrajectoryCollection.hh"
#include "MCDataProducts/inc/SimParticleCollection.hh"
#include "MCDataProducts/inc/SimParticlePtrCollection.hh"
#include "MCDataProducts/inc/StatusG4.hh"
#include "MCDataProducts/inc/StepPointMCCollection.hh"
#include "MCDataProducts/inc/StrawHitMCTruthCollection.hh"
#include "MCDataProducts/inc/StrawDigiMCCollection.hh"
#include "MCDataProducts/inc/PtrStepPointMCVectorCollection.hh"
#include "MCDataProducts/inc/MixingSummary.hh"
#include "MCDataProducts/inc/VisibleGenElTrackCollection.hh"
#include "MCDataProducts/inc/GenParticleSPMHistory.hh"
#include "MCDataProducts/inc/GenSimParticleLink.hh"
#include "MCDataProducts/inc/ExtMonFNALSimHit.hh"
#include "MCDataProducts/inc/ExtMonFNALSimHitCollection.hh"
#include "MCDataProducts/inc/ExtMonFNALHitTruthAssn.hh"
#include "MCDataProducts/inc/ExtMonFNALRecoClusterTruthAssn.hh"
#include "MCDataProducts/inc/ExtMonFNALPatRecTruthAssns.hh"
#include "MCDataProducts/inc/MARSInfo.hh"
#include "MCDataProducts/inc/MARSInfoCollection.hh"
#include "MCDataProducts/inc/GenParticleMARSAssns.hh"
#include "MCDataProducts/inc/SimParticleMARSAssns.hh"
#include "MCDataProducts/inc/SimParticleTimeMap.hh"
#include "MCDataProducts/inc/SimParticleRemapping.hh"

#include "MCDataProducts/inc/StepFilterMode.hh"
#include "MCDataProducts/inc/GenEventCount.hh"
#include "MCDataProducts/inc/EventWeight.hh"

#include "MCDataProducts/inc/TrackSummaryTruthAssns.hh"
#include "MCDataProducts/inc/SimParticleTrackerHitSummaryCollection.hh"
#include "MCDataProducts/inc/SimParticleTrackerHitSummaryAssns.hh"
#include "MCDataProducts/inc/ProtonBunchIntensity.hh"

#include "DataProducts/inc/CRSScintillatorBarIndex.hh"

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[]={
"art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >", payloadCode, "@",
"art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> >", payloadCode, "@",
"art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo>", payloadCode, "@",
"art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void>", payloadCode, "@",
"art::Assns<mu2e::GenParticle,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> >", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> >", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo>", payloadCode, "@",
"art::Assns<mu2e::SimParticle,mu2e::TrackSummary,void>", payloadCode, "@",
"art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void>", payloadCode, "@",
"art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo>", payloadCode, "@",
"art::Assns<mu2e::TrackSummary,mu2e::SimParticle,void>", payloadCode, "@",
"art::Ptr<mu2e::CaloDigi>", payloadCode, "@",
"art::Ptr<mu2e::CaloShowerSim>", payloadCode, "@",
"art::Ptr<mu2e::CaloShowerStep>", payloadCode, "@",
"art::Ptr<mu2e::GenParticle>", payloadCode, "@",
"art::Ptr<mu2e::SimParticle>", payloadCode, "@",
"art::Ptr<mu2e::StepPointMC>", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::CaloCluster,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,art::Ptr<mu2e::CaloShowerSim> > >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::CaloCrystalHit,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,mu2e::ExtMonFNALHitTruthBits> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALRawHit,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,mu2e::ExtMonFNALRecoClusterTruthBits> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALRecoCluster,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,mu2e::ExtMonFNALTrkMatchInfo> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::ExtMonFNALTrkFit,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::MARSInfo,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::GenParticle,mu2e::StepPointMC,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,art::Ptr<mu2e::CaloShowerSim> > >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCluster,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,art::Ptr<mu2e::CaloShowerSim> > >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::CaloCrystalHit,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,mu2e::ExtMonFNALHitTruthBits> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRawHit,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,mu2e::ExtMonFNALRecoClusterTruthBits> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALRecoCluster,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,mu2e::ExtMonFNALTrkMatchInfo> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::ExtMonFNALTrkFit,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::MARSInfo,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::SimParticleTrackerHitSummary,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticle,mu2e::TrackSummary,mu2e::TrackSummaryMatchInfo> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::SimParticleTrackerHitSummary,mu2e::SimParticle,void> >", payloadCode, "@",
"art::Wrapper<art::Assns<mu2e::TrackSummary,mu2e::SimParticle,mu2e::TrackSummaryMatchInfo> >", payloadCode, "@",
"art::Wrapper<cet::map_vector<mu2e::PointTrajectory> >", payloadCode, "@",
"art::Wrapper<cet::map_vector<mu2e::SimParticle> >", payloadCode, "@",
"art::Wrapper<map<art::Ptr<mu2e::SimParticle>,art::Ptr<mu2e::SimParticle> > >", payloadCode, "@",
"art::Wrapper<map<art::Ptr<mu2e::SimParticle>,double> >", payloadCode, "@",
"art::Wrapper<map<art::Ptr<mu2e::SimParticle>,mu2e::MCTrajectory> >", payloadCode, "@",
"art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvDigiMC> >", payloadCode, "@",
"art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvPhotons> >", payloadCode, "@",
"art::Wrapper<map<mu2e::CRSScintillatorBarIndex,mu2e::CrvSiPMCharges> >", payloadCode, "@",
"art::Wrapper<mu2e::CaloDigi>", payloadCode, "@",
"art::Wrapper<mu2e::CaloDigiCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloDigiMCCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloHitMCTruthCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloHitSimPartMCCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloShowerSimCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloShowerStepCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CaloShowerStepROCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CrvDigiMCCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CrvPhotonsCollection>", payloadCode, "@",
"art::Wrapper<mu2e::CrvSiPMChargesCollection>", payloadCode, "@",
"art::Wrapper<mu2e::EventWeight>", payloadCode, "@",
"art::Wrapper<mu2e::ExtMonFNALSimHitCollection>", payloadCode, "@",
"art::Wrapper<mu2e::ExtMonUCITofHitMCTruthCollection>", payloadCode, "@",
"art::Wrapper<mu2e::G4BeamlineInfo>", payloadCode, "@",
"art::Wrapper<mu2e::G4BeamlineInfoCollection>", payloadCode, "@",
"art::Wrapper<mu2e::GenEventCount>", payloadCode, "@",
"art::Wrapper<mu2e::GenParticleCollection>", payloadCode, "@",
"art::Wrapper<mu2e::GenParticleMARSAssns>", payloadCode, "@",
"art::Wrapper<mu2e::GenParticleSPMHistory>", payloadCode, "@",
"art::Wrapper<mu2e::GenSimParticleLink>", payloadCode, "@",
"art::Wrapper<mu2e::MARSInfoCollection>", payloadCode, "@",
"art::Wrapper<mu2e::MCTrajectoryCollection>", payloadCode, "@",
"art::Wrapper<mu2e::MixingSummary>", payloadCode, "@",
"art::Wrapper<mu2e::PhysicalVolumeInfoCollection>", payloadCode, "@",
"art::Wrapper<mu2e::PhysicalVolumeInfoMultiCollection>", payloadCode, "@",
"art::Wrapper<mu2e::PointTrajectoryCollection>", payloadCode, "@",
"art::Wrapper<mu2e::ProtonBunchIntensity>", payloadCode, "@",
"art::Wrapper<mu2e::PtrStepPointMCVectorCollection>", payloadCode, "@",
"art::Wrapper<mu2e::SimParticleCollection>", payloadCode, "@",
"art::Wrapper<mu2e::SimParticleMARSAssns>", payloadCode, "@",
"art::Wrapper<mu2e::SimParticlePtrCollection>", payloadCode, "@",
"art::Wrapper<mu2e::SimParticleRemapping>", payloadCode, "@",
"art::Wrapper<mu2e::SimParticleTimeMap>", payloadCode, "@",
"art::Wrapper<mu2e::StatusG4>", payloadCode, "@",
"art::Wrapper<mu2e::StepPointMCCollection>", payloadCode, "@",
"art::Wrapper<mu2e::StrawDigiMCCollection>", payloadCode, "@",
"art::Wrapper<mu2e::StrawHitMCTruthCollection>", payloadCode, "@",
"art::Wrapper<mu2e::VisibleGenElTrackCollection>", payloadCode, "@",
"art::Wrapper<vector<art::Ptr<mu2e::SimParticle> > >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloDigi> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloDigiMC> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloHitMCTruth> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloHitSimPartMC> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloShowerSim> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloShowerStep> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::CaloShowerStepRO> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::ExtMonFNALSimHit> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::ExtMonUCITofHitMCTruth> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::G4BeamlineInfo> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::GenParticle> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::MARSInfo> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::PhysicalVolumeInfo> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::StepPointMC> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::StrawDigiMC> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::StrawHitMCTruth> >", payloadCode, "@",
"art::Wrapper<vector<mu2e::VisibleGenElTrack> >", payloadCode, "@",
"art::Wrapper<vector<pair<unsigned int,cet::map_vector<mu2e::PhysicalVolumeInfo> > > >", payloadCode, "@",
"art::Wrapper<vector<vector<art::Ptr<mu2e::StepPointMC> > > >", payloadCode, "@",
"cet::map_vector<mu2e::PhysicalVolumeInfo>", payloadCode, "@",
"cet::map_vector<mu2e::PointTrajectory>", payloadCode, "@",
"cet::map_vector<mu2e::SimParticle>", payloadCode, "@",
"mu2e::CaloClusterContentMC", payloadCode, "@",
"mu2e::CaloDigi", payloadCode, "@",
"mu2e::CaloDigiCollection", payloadCode, "@",
"mu2e::CaloDigiMC", payloadCode, "@",
"mu2e::CaloDigiMCCollection", payloadCode, "@",
"mu2e::CaloHitMCTruth", payloadCode, "@",
"mu2e::CaloHitMCTruthCollection", payloadCode, "@",
"mu2e::CaloHitSimPartMC", payloadCode, "@",
"mu2e::CaloHitSimPartMCCollection", payloadCode, "@",
"mu2e::CaloShowerSim", payloadCode, "@",
"mu2e::CaloShowerSimCollection", payloadCode, "@",
"mu2e::CaloShowerStep", payloadCode, "@",
"mu2e::CaloShowerStepCollection", payloadCode, "@",
"mu2e::CaloShowerStepRO", payloadCode, "@",
"mu2e::CaloShowerStepROCollection", payloadCode, "@",
"mu2e::CrvDigiMC", payloadCode, "@",
"mu2e::CrvDigiMC::CrvSingleWaveform", payloadCode, "@",
"mu2e::CrvDigiMCCollection", payloadCode, "@",
"mu2e::CrvPhotons", payloadCode, "@",
"mu2e::CrvPhotons::SinglePhoton", payloadCode, "@",
"mu2e::CrvPhotonsCollection", payloadCode, "@",
"mu2e::CrvSiPMCharges", payloadCode, "@",
"mu2e::CrvSiPMCharges::CrvSingleCharge", payloadCode, "@",
"mu2e::CrvSiPMChargesCollection", payloadCode, "@",
"mu2e::EventWeight", payloadCode, "@",
"mu2e::ExtMonFNALHitTruthBits", payloadCode, "@",
"mu2e::ExtMonFNALPatRecTruthAssns", payloadCode, "@",
"mu2e::ExtMonFNALRecoClusterTruthBits", payloadCode, "@",
"mu2e::ExtMonFNALSimHit", payloadCode, "@",
"mu2e::ExtMonFNALSimHitCollection", payloadCode, "@",
"mu2e::ExtMonFNALTrkMatchInfo", payloadCode, "@",
"mu2e::ExtMonUCITofHitMCTruth", payloadCode, "@",
"mu2e::ExtMonUCITofHitMCTruthCollection", payloadCode, "@",
"mu2e::G4BeamlineInfo", payloadCode, "@",
"mu2e::G4BeamlineInfoCollection", payloadCode, "@",
"mu2e::GenElHitData", payloadCode, "@",
"mu2e::GenEventCount", payloadCode, "@",
"mu2e::GenId", payloadCode, "@",
"mu2e::GenParticle", payloadCode, "@",
"mu2e::GenParticleCollection", payloadCode, "@",
"mu2e::GenParticleMARSAssns", payloadCode, "@",
"mu2e::GenParticleSPMHistory", payloadCode, "@",
"mu2e::GenSimParticleLink", payloadCode, "@",
"mu2e::MARSInfo", payloadCode, "@",
"mu2e::MARSInfoCollection", payloadCode, "@",
"mu2e::MCTrajectory", payloadCode, "@",
"mu2e::MixingSummary", payloadCode, "@",
"mu2e::PDGCode", payloadCode, "@",
"mu2e::PhysicalVolumeInfo", payloadCode, "@",
"mu2e::PhysicalVolumeInfoCollection", payloadCode, "@",
"mu2e::PhysicalVolumeInfoMultiCollection", payloadCode, "@",
"mu2e::PointTrajectory", payloadCode, "@",
"mu2e::PointTrajectoryCollection", payloadCode, "@",
"mu2e::ProcessCode", payloadCode, "@",
"mu2e::ProtonBunchIntensity", payloadCode, "@",
"mu2e::PtrStepPointMCVector", payloadCode, "@",
"mu2e::PtrStepPointMCVectorCollection", payloadCode, "@",
"mu2e::SimParticle", payloadCode, "@",
"mu2e::SimParticleCollection", payloadCode, "@",
"mu2e::SimParticleMARSAssns", payloadCode, "@",
"mu2e::SimParticlePtrCollection", payloadCode, "@",
"mu2e::SimParticleRemapping", payloadCode, "@",
"mu2e::SimParticleTimeMap", payloadCode, "@",
"mu2e::SimParticleTrackerHitSummary", payloadCode, "@",
"mu2e::StatusG4", payloadCode, "@",
"mu2e::StepFilterMode", payloadCode, "@",
"mu2e::StepPointMC", payloadCode, "@",
"mu2e::StepPointMCCollection", payloadCode, "@",
"mu2e::StrawDigiMC", payloadCode, "@",
"mu2e::StrawDigiMCCollection", payloadCode, "@",
"mu2e::StrawHitMCTruth", payloadCode, "@",
"mu2e::StrawHitMCTruthCollection", payloadCode, "@",
"mu2e::TrackSummaryMatchInfo", payloadCode, "@",
"mu2e::VisibleGenElTrack", payloadCode, "@",
"mu2e::VisibleGenElTrackCollection", payloadCode, "@",
nullptr};

    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("libmu2e_.._.._.._.._.._.._.._.._.._.._.._mu2e_app_users_whyaqm_Offline_MCDataProducts_dict",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict_Impl, {}, classesHeaders);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict() {
  TriggerDictionaryInitialization_libmu2e_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_dOdO_mu2e_app_users_whyaqm_Offline_MCDataProducts_dict_Impl();
}
